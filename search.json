[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Intro to Python  Part III Systems Biology  University of Cambridge",
    "section": "",
    "text": "Overview\nThis course is designed to equip all members of the Part III Systems Biology cohort at the University of Cambridge with a foundational understanding of Python. This will be utilised in various subsequent sections of the programme. While no prior knowledge of Python is required, basic familiarity with coding is assumed. Additionally, this course may serve as a valuable introduction for those interested in learning Python for data science, particularly for those working with biological data.",
    "crumbs": [
      "Welcome",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Overview</span>"
    ]
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "Intro to Python  Part III Systems Biology  University of Cambridge",
    "section": "",
    "text": "Aims\n\n\n\n\nIntroduce participants to the core features of Python, emphasising its strengths and limitations in data science applications.\nProvide a comprehensive overview of Python syntax, data types, and operators.\nCover key programming concepts in Python, including loops, conditionals, functions, and classes; alongside an introduction to the object-oriented programming paradigm.\nDiscuss error handling, edge case management, memory management, code optimisation, and benchmarking.\nIntroduce package installation and management, as well as environment management using pip and conda.\nGuide participants in the manipulation and visualisation of biological data using widely-used Python packages, including NumPy, Pandas, Matplotlib, and Seaborn.\n\n\n\n\nTarget Audience\nThis course is targeted at Part III Systems Biology students at the University of Cambridge. All students attending should have some basic programming experience, however familiarity with Python is not essential.\nSome participants may have completed the introductory Python practical in the Part II Mathematical and Computational Biology module of the Natural Sciences Tripos. This course will refresh and extend further the concepts introduced there.\n\n\nPrerequisites\n\nHave some prior experience in coding, whether in Python or another programming language.\nHave followed the instructions on the Data and Setup page to install python, mamba/conda, and jupyterlab.\nAn understanding of biological terms (GCSE level Biology) would be beneficial.\n\n\n\n\nExercises\nExercises in these materials are labelled according to their level of difficulty:\n\n\n\n\n\n\n\nLevel\nDescription\n\n\n\n\n  \nExercises in level 1 are simpler and designed to get you familiar with the concepts and syntax covered in the course.\n\n\n  \nExercises in level 2 are more complex and may combine different concepts together and apply it to a given task.\n\n\n  \nExercises in level 3 may be challenging and require going beyond the concepts and syntax introduced to solve new problems.",
    "crumbs": [
      "Welcome",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Overview</span>"
    ]
  },
  {
    "objectID": "index.html#citation",
    "href": "index.html#citation",
    "title": "Intro to Python  Part III Systems Biology  University of Cambridge",
    "section": "Citation",
    "text": "Citation\nPlease cite these materials if for example:\n\nYou adapted or used any of them in your own teaching.\nThese materials were useful for your research work.\n\nYou can cite these materials as:\n\nShah, K. (2025). Intro to Python, Part III Systems Biology, University of Cambridge. https://doi.org/10.5281/zenodo.14651795\n\nOr in BibTeX format:\n@misc{YourReferenceHere,\n  author = {Shah, Kavi Haria},\n  month = {1},\n  title = {Intro to Python, Part III Systems Biology, University of Cambridge},\n  url = {https://doi.org/10.5281/zenodo.14651795},\n  year = {2025}\n}\nAbout the authors:\nKavi Haria Shah  \nAffiliation: Department of Genetics, University of Cambridge Roles: writing; conceptualisation; software",
    "crumbs": [
      "Welcome",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Overview</span>"
    ]
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "Intro to Python  Part III Systems Biology  University of Cambridge",
    "section": "Acknowledgements",
    "text": "Acknowledgements\n\nReferences\nTavares, H., van Rongen, M., Cardona, A. (2024). Course Development Guidelines. https://cambiotraining.github.io/quarto-course-template/\nPython Programming, NST Part IB Mathematical and Computational Biology, ac812.github.io/mcb-python/\nW3Schools, Python Operators, https://www.w3schools.com/python/python_operators.asp\nPython Documentation, https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not\nWaskom, M. L., (2021). seaborn: statistical data visualization. Journal of Open Source Software, 6(60), 3021, https://doi.org/10.21105/joss.03021. https://seaborn.pydata.org/\nJ. D. Hunter, “Matplotlib: A 2D Graphics Environment”, Computing in Science & Engineering, vol. 9, no. 3, pp. 90-95, 2007. https://matplotlib.org/stable/index.html\nNumPy Documentation https://numpy.org/doc/\nPandas Documentation https://pandas.pydata.org/docs/\nRachel Lyne et al. 2022, HumanMine: advanced data searching, analysis and cross-species comparison, https://doi.org/10.1093/database/baac054\nCock, P.J.A. et al. Biopython: freely available Python tools for computational molecular biology and bioinformatics. Bioinformatics 2009 Jun 1; 25(11) 1422-3 https://doi.org/10.1093/bioinformatics/btp163 pmid:19304878\nThe cryptography developers cryptography-dev@python.org cryptography 43.0.1 https://pypi.org/project/cryptography/ https://cryptography.io/en/latest/\n\n\nImages/Data Sources\nNote: The data has been manipulated/modified to create exercises and therefore not representative of the source\nmaricuchi_reina; Dog, Animal, Mammal image. Free for use.; via Pixabay; https://pixabay.com/photos/dog-animal-mammal-canine-domestic-8946829/\nOpenClipart-Vectors; Brain Neuron Nerves royalty-free vector graphic. Free for use & download.; via Pixabay; https://pixabay.com/vectors/brain-neuron-nerves-cell-science-2022398/\nHumanmine https://humanmine.org/humanmine\nUK HSA infectious diesease data https://www.gov.uk/government/publications/",
    "crumbs": [
      "Welcome",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Overview</span>"
    ]
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "Data & Setup",
    "section": "",
    "text": "Data\nThe data used in these materials is provided here:\nData for Session 1 and 2:\nDownload\nData for Session 3 Escape Room:\nDownload",
    "crumbs": [
      "Welcome",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data & Setup</span>"
    ]
  },
  {
    "objectID": "setup.html#wsl2-microsoft-windows-machines",
    "href": "setup.html#wsl2-microsoft-windows-machines",
    "title": "Data & Setup",
    "section": "WSL2 (Microsoft Windows machines)",
    "text": "WSL2 (Microsoft Windows machines)\nThere are detailed instructions on how to install WSL on the Microsoft documentation page. But briefly:\n\nClick the Windows key and search for Windows PowerShell, right-click on the app and choose Run as administrator.\nAnswer “Yes” when it asks if you want the App to make changes on your computer.\nA terminal will open; run the command: wsl --install.\n\nThis should start installing “ubuntu”.\nIt may ask for you to restart your computer.\n\nAfter restart, click the Windows key and search for Ubuntu, click on the App and it should open a new terminal.\nFollow the instructions to create a username and password (you can use the same username and password that you have on Windows, or a different one - it’s your choice).\n\nNote: when you type your password nothing seems to be happening as the cursor doesn’t move. However, the terminal is recording your password as you type. You will be asked to type the new password again to confirm it, so you can always try again if you get it wrong the first time.\n\nYou should now have access to a Ubuntu Linux terminal. This behaves very much like a regular Ubuntu server, and you can install apps using the sudo apt install command as usual.\n\n\nConfiguring WSL2\nAfter installation, it is useful to create shortcuts to your files on Windows. Your main C:\\ drive is located in /mnt/c/ and other drives will be equally available based on their letter. It may be convenient to create shortcuts to commonly-used directories, which you can do using symbolic links. Here are some commands to automatically create shortcuts to your Windows “Documents”, “Desktop” and “Downloads” folders:\nln -s $(wslpath $(powershell.exe '[environment]::getfolderpath(\"mydocuments\")')) ~/Documents\nln -s $(wslpath $(powershell.exe '[environment]::getfolderpath(\"desktop\")')) ~/Desktop\nln -s $(wslpath $(powershell.exe '[environment]::getfolderpath(\"downloads\")')) ~/Downloads\nYou may also want to configure the Windows terminal to automatically open WSL2 (instead of the default Windows Command Prompt or Powershell):\n\nSearch for and open the “ Terminal” application.\nClick on the downward arrow “” in the toolbar.\nClick on “ Settings”.\nUnder “Default Profile” select “ Ubuntu”.",
    "crumbs": [
      "Welcome",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data & Setup</span>"
    ]
  },
  {
    "objectID": "setup.html#python",
    "href": "setup.html#python",
    "title": "Data & Setup",
    "section": "Python",
    "text": "Python\nWe recommend using the package manager Mamba to manage your Python installation and environments. Our recommendation is to create separate environments for each project or type of analysis, to avoid package version conflicts. In this page we give an example of creating an environment for our Python introduction course, which includes Jupyter Lab and some essential packages for data analysis. You will need python version 3.11 or later for this course.\n\n\n\n\n\n\nFirst install Mamba\n\n\n\nFollow the instructions on the mamba installation page. Then return to this page.\n\n\n\nOpen a terminal (macOS and Linux) or the Miniforge prompt (Windows)\n\nEnsure that the shell starts with the word (base), indicating Mamba is correctly installed.\n\nCreate a new environment, which we will call pycourse (you may give your environment a name of your choice):\nmamba create -n pycourse python=3.11\nInstall JupyterLab (for notebook interface):\nmamba install -y -n pycourse jupyterlab\nThe installation should complete with the following message:\nDownloading and Extracting Packages\n\nPreparing transaction: done\nVerifying transaction: done\nExecuting transaction: done\nOnce installed, you can start JupyterLab by activating your environment and running the command to launch it:\nmamba activate pycourse\njupyter lab\nJupyterLab should open in your browser automatically. If it doesn’t, you can click the link that appears on the message printed on the screen:",
    "crumbs": [
      "Welcome",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data & Setup</span>"
    ]
  },
  {
    "objectID": "materials/01-why-learn-python.html",
    "href": "materials/01-why-learn-python.html",
    "title": "3  Why Learn Python",
    "section": "",
    "text": "3.1 What is Python?\nHigh-Level, General-Purpose Language:\nPython is a versatile programming language created in the late 1980s by Guido van Rossum, emphasising code readability and simplicity. It is widely used for tasks like web development, machine learning, and automation.\nNamed After: “Monty Python’s Flying Circus” (not the reptile).\nKey Features:\nCPython is the most widely used implementation of Python. Jupyter Notebooks use IPython (Interactive Python), which is an enhanced interactive shell built on top of CPython. Other implementations of Python include Jython, which is written in Java, among others.\nWe won’t go into further detail here, but for more information, see:\nQiang Zhang, Lei Xu, Baowen Xu 2023 , Python meets JIT compilers: A simple implementation and a comparative evaluation https://doi.org/10.1002/spe.3267 https://onlinelibrary.wiley.com/doi/full/10.1002/spe.3267\nGeeksforGeeks 2023, Difference between various Implementations of Python https://www.geeksforgeeks.org/difference-various-implementations-python/\nIPython Interactive Computing https://ipython.org/",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Why Learn Python</span>"
    ]
  },
  {
    "objectID": "materials/01-why-learn-python.html#what-is-python",
    "href": "materials/01-why-learn-python.html#what-is-python",
    "title": "3  Why Learn Python",
    "section": "",
    "text": "Interpreted Language: Executes code line-by-line, making debugging easier compared to compiled languages.\nObject-Oriented Programming (OOP): Supports the OOP paradigm through classes and objects, enabling structured, reusable, and scalable code for larger projects.\nVery High-Level Language (VHLL): Allows complex operations to be expressed in simple, single statements.",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Why Learn Python</span>"
    ]
  },
  {
    "objectID": "materials/01-why-learn-python.html#why-python-is-great-for-data-science",
    "href": "materials/01-why-learn-python.html#why-python-is-great-for-data-science",
    "title": "3  Why Learn Python",
    "section": "3.2 Why Python is Great for Data Science",
    "text": "3.2 Why Python is Great for Data Science\nSimple Syntax and Readability:\n\nPython’s easy-to-understand syntax helps data scientists focus on solving problems rather than dealing with complex code, making it accessible for both beginners and experts.\n\nLarge Ecosystem of Libraries:\n\nNumPy: For numerical computations and array handling.\nPandas: For data manipulation and analysis.\nMatplotlib & Seaborn: Data visualization tools.\n*Scikit-learn: Machine learning algorithms.\n*TensorFlow & PyTorch: For deep learning and neural networks.\n\n*not covered in this intro course\nActive Community and Support:\n\nPython has a large supportive community, offering tutorials, open-source contributions, and plenty of resources.\n\nIntegration with Other Tools:\n\nPython works seamlessly with databases, web scraping tools, and big data technologies like Hadoop and Apache Spark.\n\nIdeal for Prototyping and Interactive Experimentation:\n\nPython’s flexibility allows for quick algorithm testing and experimentation, which is essential for refining data models. It is not a compiled language making debugging and modifying code easier.\n\nScalability:\n\nPython can handle both small and large-scale applications, especially when combined with performance-boosting libraries or extensions written in languages like C or C++.\n\nDominant in Machine Learning and AI:\n\nPython’s libraries like Scikit-learn, TensorFlow, PyTorch and Keras simplify complex machine learning and AI tasks.",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Why Learn Python</span>"
    ]
  },
  {
    "objectID": "materials/01-why-learn-python.html#what-are-the-disadvantages-of-python",
    "href": "materials/01-why-learn-python.html#what-are-the-disadvantages-of-python",
    "title": "3  Why Learn Python",
    "section": "3.3 What are the Disadvantages of Python",
    "text": "3.3 What are the Disadvantages of Python\nWhile Python is a widely used and popular programming language, it does have some disadvantages. Here are some of them:\nPerformance Limitations\n\nPython is an interpreted language, which generally makes it slower than compiled languages like C or C++. This can be a concern for CPU-intensive tasks or applications requiring high-performance computing.\n\nMemory Consumption\n\nPython tends to use more memory than some other languages due to its data types, and the overhead of its dynamic typing. This can be a drawback in memory-constrained environments.\n\nErrors as a Result of Flexibility\n\nWhile dynamic typing makes Python easy to use, it can lead to runtime errors that are hard to track down and debug. The flexibility in coding styles and lack of need to strictly specify data types etc., can sometimes lead to less readable and maintainable code if developers don’t adhere to best practices.\n\nLimited Packages for Certain Use Cases\n\nWhile Python has many packages and modules, there are still areas, especially niche or specialized fields, where these may be limited compared to languages like R or Java.\n\nPackage Dependency Management\n\nManaging dependencies in Python can be tricky, particularly with conflicting library versions. Tools like package managers and virtual environments are helpful, but issues still arise in complex projects.",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Why Learn Python</span>"
    ]
  },
  {
    "objectID": "materials/01-why-learn-python.html#summary",
    "href": "materials/01-why-learn-python.html#summary",
    "title": "3  Why Learn Python",
    "section": "3.4 Summary",
    "text": "3.4 Summary\nPython’s ease of use, broad library support, and strong community, make it a top choice for data science. Python is ideal for data analysis, machine learning, and visualization, allowing data scientists to work efficiently and effectively. However, there are downsides to using python as mentioned above. Overall, choosing a specific programming language for a computational task is a mixture of how good it is at addressing the task, and how familiar you are with the language.\n\n\n\n\n\n\nExercise 1 - Discussion: Deciding to use Python\n\n\n\n\n\n\nLevel: \nWhat are some examples of when you would use Python and why? What are examples of when you wouldn’t use Python and why?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nAt the moment you may not use Python for very much unless you are already familiar with it.\nYou might choose to use Python to train a neural network for image recognition, but not for programming a microcontroller where you might use C++, even though CircuitPython is available.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nPython is defined by its syntax, and is an easy to use high level language commonly used in data science\nPython has many packages and modules for data science and AI\nThere are both advantages and disadvantages to programming in python, so choose a programming language suited to the task",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Why Learn Python</span>"
    ]
  },
  {
    "objectID": "materials/02-starting-in-python.html",
    "href": "materials/02-starting-in-python.html",
    "title": "4  Starting in Python",
    "section": "",
    "text": "4.1 Basic Python Syntax\nComments and new lines\nCommenting your code, and using lines liberally, are key to making your code easily understandable for others.\nAssigning variables\nIn Python initialising variables is easy:\nVariable Naming Conventions in Python\nWhen naming variables, it’s important to follow Python’s guidelines for consistency and readability. Here are some key rules to remember:\nFor more detailed guidelines, refer to PEP 8 or the Google Python Style Guide.\nIndentation\nIn python indentation is used to define code blocks. We will see more of this later when we get to conditional statements and loops. - Unexpected indents will result in errors. - indents are 4 spaces according to PEP 8 standards, however commonly also two spaces on web interfaces. Be consistent. - Using spaces is preferable to using tabs\nThe above would produce an error",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Starting in Python</span>"
    ]
  },
  {
    "objectID": "materials/02-starting-in-python.html#basic-python-syntax",
    "href": "materials/02-starting-in-python.html#basic-python-syntax",
    "title": "4  Starting in Python",
    "section": "",
    "text": "A # (Hash) is used for single line comments\nA \"\"\" (triple quotes) is used around multiline comments or strings\nA \\ (backslash) is used to explicitly break a line\nLines can be implicitly continued in some cases, for example when in brackets. We will see this later.\n\n\n\n\n\nVariables are assigned using the = sign\nCase sensitive\nNo need to declare the type explicitly (dynamic typing)\n\n# Initialising my_height in cm \nmy_height = 176\nmy_name = \"Kavi\"\n\n\n\n\n\nCase-sensitive: weight and Weight are different variables.\nUse lowercase: Separate words with underscores, e.g., weight_kg.\nDon’t start with numbers: Variable names cannot begin with a digit.\nStick to letters: Use only letters, underscores, and digits (when needed).\nBe descriptive: Choose clear, meaningful names (e.g., asdjks is not helpful).\nAvoid overly long names: For example ‘this_is_my_height_in_cm’ is too long.\nDon’t use keywords: Avoid using Python function names, class names, or data types as variable names.\n\n\n\n\n\n# Initialising my_height in cm \nmy_height = 176\n my_name = \"Kavi\"",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Starting in Python</span>"
    ]
  },
  {
    "objectID": "materials/02-starting-in-python.html#calling-a-function",
    "href": "materials/02-starting-in-python.html#calling-a-function",
    "title": "4  Starting in Python",
    "section": "4.2 Calling a function",
    "text": "4.2 Calling a function\nFunctions are chunks of code which produce an output. They can (but do not have to) take user defined inputs. Python ships with many in built functions. See: https://docs.python.org/3/library/functions.html\nTo call a function, simply use the function name followed by parentheses. If the function takes parameters, provide the arguments inside the parentheses. - functions may take arguments in an order separated by a comma:\nfunction(a, b) \n\nalternatively functions may use assignment for inputs:\n\nfunction(a, type = b)\n\nvariable inputs into functions can defined globally\n\nb = number\nfunction(a, type = b)\n\nFunctions can have default inputs if none specified\nfunctions can be nested although this can make code less readable\n\nfunction_two(function_one(a))\n\n\n\n\n\n\nExercise 1 - Print ’Hello World”\n\n\n\n\n\n\nLevel: \nOpen the python console in command line. Use variable assignment and the print() function assign “Hello World!” to the message variable and print it in standard output\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nmessage = \"Hello World!\"\nprint(message)",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Starting in Python</span>"
    ]
  },
  {
    "objectID": "materials/02-starting-in-python.html#using-the-type-function",
    "href": "materials/02-starting-in-python.html#using-the-type-function",
    "title": "4  Starting in Python",
    "section": "4.3 Using the type() function",
    "text": "4.3 Using the type() function\nAs mentioned python uses dynamic typing. The type() function can output the datatype assigned to a variable\n\n\n\n\n\n\nExercise 2 - Find the data type\n\n\n\n\n\n\nLevel: \nWhat is the data type of the message variable? Print it to Standard output\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nprint(type(message))\noutput:\n&lt;class 'str'&gt;\nIt is a string",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Starting in Python</span>"
    ]
  },
  {
    "objectID": "materials/02-starting-in-python.html#using-jupyter-notebooks",
    "href": "materials/02-starting-in-python.html#using-jupyter-notebooks",
    "title": "4  Starting in Python",
    "section": "4.4 Using Jupyter Notebooks",
    "text": "4.4 Using Jupyter Notebooks\nPython programs (.py files) are essential in data analysis and structured software development. In this course, we will primarily use Jupyter Notebooks for coding. Jupyter Notebooks enable literate programming by merging natural language (like English) with source code in a single document. Instead of separate text documents and .py files, Jupyter Notebooks integrate both functionalities, making analyses and code reproducible. This is important for FAIR (Findable, Accessible, Interoperable, and Reproducible) research standards.\nThe name “Jupyter” derives from its core languages: Julia, Python, and R, with its logo inspired by Galileo’s discovery of Jupiter’s moons. Each coding language has its own kernel for executing code cells. For Python, the kernel is IPython. Jupyter Notebook files have a ‘.ipynb’ extension, indicating their connection to IPython.\nThe Jupyter Notebook file, kernel, and web browser interact via the Jupyter Notebook Server, enabling a seamless user experience.\nFor a more in-depth look at Jupyter Notebooks, refer to the MCB course: https://ac812.github.io/mcb-python/jupyter.html\n\n\n\n\n\n\nExercise 3 - Create a Jupyter Notebook\n\n\n\n\n\n\nLevel: \nYou should have already installed Jupyter Notebook. Launch a Jupyter Notebook from the terminal:\njupyter notebook\nCreate a new python file and print “Hello World!” in a code chunk. Add a text chunk and describe what you have done. Save the file.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nIn the Jupyter Notebook interface, you willl see a list of files and folders in the current directory. 1. Click on the New button on the right side of the interface. 2. From the dropdown menu, select Python 3 (or whichever version you have installed). This will create a new notebook. 3. You will see a new notebook open up with a cell where you can write Python code. Add:\nprint(\"Hello, World!\")\n\nRun the Code by clicking on the cell containing the code. Press Shift + Enter on your keyboard, or click the Run button in the toolbar.\nSave Your Notebook by clicking on the File menu at the top left. Select Save and Checkpoint or press Ctrl + S (Windows) or Cmd + S (Mac).",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Starting in Python</span>"
    ]
  },
  {
    "objectID": "materials/02-starting-in-python.html#summary",
    "href": "materials/02-starting-in-python.html#summary",
    "title": "4  Starting in Python",
    "section": "4.5 Summary",
    "text": "4.5 Summary\nYou should now be able to call in-built functions in python and be set up to use Jupyter Notebooks.\n\n\n\n\n\n\nKey Points\n\n\n\n\nPython uses # for comments\nVariables are assigned with =\nThere is no need to define the variable type explicitly\nIndentation is used in python to identify code chunks\nJupyter Notebooks enable literate programming in python, combining code chunks and markdown text",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Starting in Python</span>"
    ]
  },
  {
    "objectID": "materials/03-data-types-in-python.html",
    "href": "materials/03-data-types-in-python.html",
    "title": "5  Data Types in Python",
    "section": "",
    "text": "5.1 Inbuilt Data Types\nIn programming, data type is an important concept. Variables can store data of different types, and different types can do different things.\nPython has the following data types built-in without needing any other libraries:\nSimple/primitive data types:\nComposite Datatypes / data structures\nWe will also look at the numpy arrays and pandas dataframes, you can also use the decimal module for correctly rounded arithmetic\nIn Python, each data type has specific use cases and trade-offs. Let’s look at each category and examine when it might be used, along with its benefits and disadvantages:\nCustom Data types",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Types in Python</span>"
    ]
  },
  {
    "objectID": "materials/03-data-types-in-python.html#inbuilt-data-types",
    "href": "materials/03-data-types-in-python.html#inbuilt-data-types",
    "title": "5  Data Types in Python",
    "section": "",
    "text": "None Type: NoneType\nBoolean Type: bool\nText Type: str\nNumeric Types: int, float, complex\nBinary Types: bytes\n\n\n\n\nSequence Types: list, tuple, range\nSet Types: set, frozenset\nMapping Type: dict\nBinary composite type: bytearray, memoryview\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCategory\nType\nCommon Use Case\nBenefits\nDisadvantages\n\n\n\n\nNone Type\nNoneType\nRepresents absence of value\nUseful for optional values and placeholders\nCan cause errors if operations expect a value\n\n\n\n\n\n\n\n\n\nBoolean\nbool\nRepresents True or False\nSimple and efficient for control flow\nLimited to two states (True/False)\n\n\n\n\n\n\n\n\n\nText\nstr\nText representation\nImmutable, Unicode support- multilingual, rich manipulation methods\nInefficient for heavy modifications\n\n\n\n\n\n\n\n\n\nNumeric\nint\nRepresents whole numbers\nNo precision issues\nLimited to integers\n\n\n\nfloat\nRepresents decimal numbers\nSupports real numbers\nPrecision issues due to storage\n\n\n\ncomplex\nRepresents complex numbers\nDirect support for complex arithmetic\nRarely needed in general programming\n\n\n\n\n\n\n\n\n\nSequence\nlist\nMutable sequence of items\nFlexible, dynamic size, rich methods\nSlower resizing operations\n\n\n\ntuple\nImmutable sequence of items\nMemory-efficient, safe\nCannot change values once set\n\n\n\nrange\nSequence of numbers\nMemory-efficient\nLess flexible than lists\n\n\n\n\n\n\n\n\n\nMapping\ndict\nKey-value pairs\nFast lookups, flexible types\nHigher memory usage due to hashing\n\n\n\n\n\n\n\n\n\nSet\nset\nUnordered collection of unique items\nFast membership testing;\nUnordered in the Python specification; no indexing\n\n\n\nfrozenset\nImmutable set\nHashable, can be used as dictionary keys\nCannot modify after creation\n\n\n\n\n\n\n\n\n\nBinary\nbytes\nImmutable binary data\nEfficient, compact for binary data\nNot human-readable, cumbersome for some operations\n\n\n\nbytearray\nMutable binary data\nAllows modification of binary data\nConsumes more memory than bytes\n\n\n\nmemoryview\nEfficient access to binary data without copying\nNo data duplication\nMore complex to use\n\n\n\n\n\nIn python it is possible to define custom data types with custom syntax and behaviours. Many of the common desired data types have already been made for you by others.",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Types in Python</span>"
    ]
  },
  {
    "objectID": "materials/03-data-types-in-python.html#initialising-and-converting-between-data-types",
    "href": "materials/03-data-types-in-python.html#initialising-and-converting-between-data-types",
    "title": "5  Data Types in Python",
    "section": "5.2 Initialising and converting between data types",
    "text": "5.2 Initialising and converting between data types\nDifferent data types have different syntax. You will notice that all inbuilt data types in python have inbuilt functions which can be used to convert to that data type or specify as that data type.\nIt is not possible to convert between all data types; some conversions require additional information and input.\nResources about data types can be found in the python documentation: https://docs.python.org/3/library/functions.html https://docs.python.org/3/library/stdtypes.html\nExamples of converting between data types:\n1. Converting int to float\nx = 5  # integer\ny = float(x)  # converting to float\nprint(y)  \nOutput:\n5.0\n2. Converting float to int\nx = 3.23  # float\ny = int(x)  # converting to int\nprint(b)\nOutput:\n3\n3. Converting int to str\nx = 10  # integer\ny = str(x)  # converting to string\nprint(y)\nOutput:\n'10'\n4. Converting str to int\nx = \"123\"  # string\ny = int(x)  # converting to int\nprint(y)\nOutput:\n123\n5. Converting str to float\nx = \"45.67\"  # string\ny = float(x)  # converting to float\nprint(x)  \nOutput:\n45.67\n6. Converting list to tuple\nmy_list = [1, 2, 3]  # list\nmy_tuple = tuple(my_list)  # converting to tuple\nprint(my_tuple)\nOutput:\n(1, 2, 3)\n7. Converting tuple to list\nmy_tuple2 = (4, 5, 6)  # tuple\nmy_list2 = list(my_tuple2)  # converting to list\nprint(my_list2)  \nOutput:\n[4, 5, 6]\n8. Converting int to bool\nnum_bool = 0  # integer\nbool_value = bool(num_bool)  # converting to boolean\nprint(bool_value)  \nOutput:\nFalse\n\n\n\n\n\n\nExercise 1 - floats to integers: what could go wrong?\n\n\n\n\n\n\nLevel: \nWhat happens when I convert 3.5 to an integer\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nThe integer displayed is output is 3. Rounding does not occur correctly\nprint(int(3.5))\nprint(int(3.7))\nThe output to both is 3. Note that the python round() function rounds the float a to the nearest integer. However with this function, if the decimal is exactly 0.5, it rounds to the nearest even number (Python’s default behavior). The alternative is to use a library, for example the decimal library.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 2 - Dictionary syntax\n\n\n\n\n\n\nLevel: \nUse the python documentation to find the syntax of a dictionary\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nThe syntax is with curly brackets and colons. See examples from the docs:\ndictionary = {'language': \"Python\", \"number\": 2}\nand\ndishes = {'eggs': 2, 'sausage': 1, 'bacon': 1, 'spam': 500}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 3 - Dictionary syntax\n\n\n\n\n\n\nLevel: \nState the best data type to use in Python:\n\nYou want to store a sequence of names that may change (e.g., adding or removing names).\nYou need to check if certain items (e.g., unique user IDs) exist in a collection and don’t care about the order.\nYou need to store an unchanging sequence of geographic coordinates (latitude, longitude).\nYou are counting the number of items in stock in an inventory system (whole numbers only).\nYou are dealing with financial calculations and need decimal values for prices and quantities.\nYou need to store data about a person (e.g., name, age, occupation) and retrieve the data by key.\nYou are processing binary data from an image file and need to modify the data.\nYou want to represent a logical condition (True or False) to check user login status.\nYou want to ensure a set of elements stays constant and cannot be modified after creation.\nA function you are writing returns nothing (i.e., no meaningful value to return).\nYou need to handle a collection of scientific data points with floating-point precision (e.g. temperature readings).\nYou are working with text that may need to be split, joined, or manipulated.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n\nlist — Ordered and mutable collection of names.\nset — For fast membership tests with unique elements, order is irrelevant.\ntuple — Immutable sequence, perfect for storing fixed data like geographic coordinates.\nint — Used for counting and working with whole numbers.\nfloat — If precision is required, consider decimal.Decimal, but float for most cases.\ndict — For key-value pairs (e.g., storing data about a person).\nbytearray — Mutable sequence of bytes, useful for modifying binary data.\nbool — Represents binary conditions (True or False).\nfrozenset — Immutable version of a set.\nNone — Represents the absence of a value, useful for functions that don’t return anything.\nfloat — Floating-point numbers are used for measurements and continuous values.\nstr — For handling textual data with built-in manipulation methods.\n\nWhich data type you use effects memory useage and speed of computations which may be important in larger programs. For further reading you can investigate why sets are generally faster to find unordered elements (membership tests) than lists or tuples",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Types in Python</span>"
    ]
  },
  {
    "objectID": "materials/03-data-types-in-python.html#summary",
    "href": "materials/03-data-types-in-python.html#summary",
    "title": "5  Data Types in Python",
    "section": "5.3 Summary",
    "text": "5.3 Summary\nThere are many in-built data types in python. We will explore them further in the next few sections. It is important to use the correct data type for your use case\n\n\n\n\n\n\nKey Points\n\n\n\n\nUse the table to remember the key information about data types\nCheck the python documentation for further information on data types and in-built functions\nIt is important to use the correct data types for your use case rather than the same data type all the time",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data Types in Python</span>"
    ]
  },
  {
    "objectID": "materials/04-python-operators.html",
    "href": "materials/04-python-operators.html",
    "title": "6  Python Operators",
    "section": "",
    "text": "6.1 What are Operators?\nIn computer science, operators are symbols or keywords used to perform operations on data and variables (operands), like calculations or comparisons. They are essential for building expressions in programming.\nOperators are classified by the type of operation:\nPython has a rich set of operators that are classified into multiple categories\nGood resources for python operators can be found at the following:\nhttps://www.w3schools.com/python/python_operators.asp https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Python Operators</span>"
    ]
  },
  {
    "objectID": "materials/04-python-operators.html#what-are-operators",
    "href": "materials/04-python-operators.html#what-are-operators",
    "title": "6  Python Operators",
    "section": "",
    "text": "Arithmetic Operators: Basic math operations (+, -, *, /).\nLogical Operators: Return True or False (AND, OR, NOT).\nRelational Operators: Compare values, returning boolean results (&gt;, &lt;, ==).\nAssignment Operators: Assign values to variables (=, +=).\nBitwise Operators: Operate on bits (&, |, ^).\nUnary/Binary Operators: Work with one or two operands respectively.",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Python Operators</span>"
    ]
  },
  {
    "objectID": "materials/04-python-operators.html#arithmetic-operators",
    "href": "materials/04-python-operators.html#arithmetic-operators",
    "title": "6  Python Operators",
    "section": "6.2 Arithmetic Operators",
    "text": "6.2 Arithmetic Operators\nThese operators perform basic arithmetic operations.\n\n\n\n\n\n\n\n\n\nOperator\nDescription\nExample\nApplicable Data Types\n\n\n\n\n+\nAddition\na + b\nint, float, complex, str, list, tuple, byte, bytearray\n\n\n-\nSubtraction\na - b\nint, float, complex\n\n\n*\nMultiplication\na * b\nint, float, complex, str, list, tuple, bytearray\n\n\n/\nDivision\na / b\nint, float, complex\n\n\n%\nModulus (remainder)\na % b\nint, float\n\n\n**\nExponentiation\na ** b\nint, float\n\n\n//\nFloor Division\na // b\nint, float",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Python Operators</span>"
    ]
  },
  {
    "objectID": "materials/04-python-operators.html#comparison-relational-operators",
    "href": "materials/04-python-operators.html#comparison-relational-operators",
    "title": "6  Python Operators",
    "section": "6.3 Comparison (Relational) Operators",
    "text": "6.3 Comparison (Relational) Operators\nThese operators compare two values and return a boolean (True or False).\n\n\n\n\n\n\n\n\n\nOperator\nDescription\nExample\nApplicable Data Types\n\n\n\n\n==\nEqual to\na == b\nint, float, str, list, tuple, set, frozenset, dict, range\n\n\n!=\nNot equal to\na != b\nint, float, str, list, tuple, set, frozenset, dict, range\n\n\n&gt;\nGreater than\na &gt; b\nint, float, str, range\n\n\n&lt;\nLess than\na &lt; b\nint, float, str, range\n\n\n&gt;=\nGreater than or equal to\na &gt;= b\nint, float, str, range\n\n\n&lt;=\nLess than or equal to\na &lt;= b\nint, float, str, range",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Python Operators</span>"
    ]
  },
  {
    "objectID": "materials/04-python-operators.html#logical-operators",
    "href": "materials/04-python-operators.html#logical-operators",
    "title": "6  Python Operators",
    "section": "6.4 Logical Operators",
    "text": "6.4 Logical Operators\nUsed to combine conditional statements.\n\n\n\n\n\n\n\n\n\nOperator\nDescription\nExample\nApplicable Data Types\n\n\n\n\nand\nLogical AND (both must be true)\na and b\nbool, int\n\n\nor\nLogical OR (either can be true)\na or b\nbool, int\n\n\nnot\nLogical NOT (negates boolean)\nnot a\nbool, int",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Python Operators</span>"
    ]
  },
  {
    "objectID": "materials/04-python-operators.html#assignment-operators",
    "href": "materials/04-python-operators.html#assignment-operators",
    "title": "6  Python Operators",
    "section": "6.5 Assignment Operators",
    "text": "6.5 Assignment Operators\nUsed to assign values to variables, sometimes with an operation included.\n\n\n\n\n\n\n\n\n\nOperator\nDescription\nExample\nApplicable Data Types\n\n\n\n\n=\nAssign\na = 5\nAll types\n\n\n+=\nAdd and assign\na += 5\nint, float, str, list, tuple, bytearray\n\n\n-=\nSubtract and assign\na -= 5\nint, float\n\n\n*=\nMultiply and assign\na *= 5\nint, float, str, list, tuple, bytearray\n\n\n/=\nDivide and assign\na /= 5\nint, float\n\n\n%=\nModulus and assign\na %= 5\nint, float\n\n\n**=\nExponentiate and assign\na **= 5\nint, float\n\n\n//=\nFloor-divide and assign\na //= 5\nint, float",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Python Operators</span>"
    ]
  },
  {
    "objectID": "materials/04-python-operators.html#bitwise-operators",
    "href": "materials/04-python-operators.html#bitwise-operators",
    "title": "6  Python Operators",
    "section": "6.6 Bitwise Operators",
    "text": "6.6 Bitwise Operators\nPerform operations at the bit level.\n\n\n\nOperator\nDescription\nExample\nApplicable Data Types\n\n\n\n\n&\nBitwise AND\na & b\nint, byte, bytearray\n\n\n|\nBitwise OR\na | b\nint, byte, bytearray\n\n\n^\nBitwise XOR\na ^ b\nint, byte, bytearray\n\n\n~\nBitwise NOT\n~a\nint, byte, bytearray\n\n\n&lt;&lt;\nLeft shift\na &lt;&lt; 2\nint, byte, bytearray\n\n\n&gt;&gt;\nRight shift\na &gt;&gt; 2\nint, byte, bytearray",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Python Operators</span>"
    ]
  },
  {
    "objectID": "materials/04-python-operators.html#membership-operators",
    "href": "materials/04-python-operators.html#membership-operators",
    "title": "6  Python Operators",
    "section": "6.7 Membership Operators",
    "text": "6.7 Membership Operators\nUsed to check membership within sequences (like strings, lists, tuples).\n\n\n\n\n\n\n\n\n\nOperator\nDescription\nExample\nApplicable Data Types\n\n\n\n\nin\nTrue if value is present\n‘a’ in ‘apple’\nstr, list, tuple, set, frozenset, dict, range\n\n\nnot in\nTrue if value is not present\n‘b’ not in ‘apple’\nstr, list, tuple, set, frozenset, dict, range",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Python Operators</span>"
    ]
  },
  {
    "objectID": "materials/04-python-operators.html#identity-operators",
    "href": "materials/04-python-operators.html#identity-operators",
    "title": "6  Python Operators",
    "section": "6.8 Identity Operators",
    "text": "6.8 Identity Operators\nUsed to compare memory locations of two objects.\n\n\n\n\n\n\n\n\n\nOperator\nDescription\nExample\nApplicable Data Types\n\n\n\n\nis\nTrue if both refer to same object\na is b\nAll types\n\n\nis not\nTrue if not same object\na is not b\nAll types",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Python Operators</span>"
    ]
  },
  {
    "objectID": "materials/04-python-operators.html#unary-operators",
    "href": "materials/04-python-operators.html#unary-operators",
    "title": "6  Python Operators",
    "section": "6.9 Unary Operators",
    "text": "6.9 Unary Operators\nOperate on a single operand.\n\n\n\n\n\n\n\n\n\nOperator\nDescription\nExample\nApplicable Data Types\n\n\n\n\n-\nNegation (unary minus)\n-a\nint, float, complex\n\n\n+\nUnary plus\n+a\nint, float, complex\n\n\nnot\nLogical NOT\nnot a\nbool, int",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Python Operators</span>"
    ]
  },
  {
    "objectID": "materials/04-python-operators.html#set-operators",
    "href": "materials/04-python-operators.html#set-operators",
    "title": "6  Python Operators",
    "section": "6.10 Set Operators",
    "text": "6.10 Set Operators\nSet-specific operators.\n\n\n\n\n\n\n\n\n\nOperator\nDescription\nExample\nApplicable Data Types\n\n\n\n\n|\nUnion (combine sets)\na | b\nset, frozenset\n\n\n&\nIntersection (common)\na & b\nset, frozenset\n\n\n-\nDifference (in a not in b)\na - b\nset, frozenset\n\n\n^\nSymmetric difference\na ^ b\nset, frozenset",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Python Operators</span>"
    ]
  },
  {
    "objectID": "materials/04-python-operators.html#order-of-precedence-for-operators",
    "href": "materials/04-python-operators.html#order-of-precedence-for-operators",
    "title": "6  Python Operators",
    "section": "6.11 Order of Precedence for operators",
    "text": "6.11 Order of Precedence for operators\nOperators are ordered in precedence in code (think BODMAS). Using parentheses can add clarity to code.\nUse the table below to see the order:\n\n\n\n\n\n\n\n\n\nPrecedence Level\nOperator(s)\nDescription\nExample\n\n\n\n\n1 (Highest)\n()\nParentheses (brackets) for grouping expressions\n(a + b) * c\n\n\n2\n**\nExponentiation\na ** b\n\n\n3\n+x, -x, ~x\nUnary plus, unary minus, bitwise NOT\n+a, -a, ~a\n\n\n4\n*, /, //, %\nMultiplication, division, floor division, modulus\na * b, a / b\n\n\n5\n+, -\nAddition, subtraction\na + b, a - b\n\n\n6\n&lt;&lt;, &gt;&gt;\nBitwise left shift, right shift\na &lt;&lt; b, a &gt;&gt; b\n\n\n7\n&\nBitwise AND\na & b\n\n\n8\n^\nBitwise XOR\na ^ b\n\n\n9\n|\nBitwise OR\na | b\n\n\n10\nin, not in\nMembership operators\n'a' in 'apple'\n\n\n11\n&lt;, &gt;, &lt;=, &gt;=, ==, !=\nComparison operators\na &lt; b, a == b\n\n\n12\nis, is not\nIdentity operators\na is b\n\n\n13\nnot\nLogical NOT\nnot a\n\n\n14\nand\nLogical AND\na and b\n\n\n15\nor\nLogical OR\na or b\n\n\n16 (Lowest)\n=, +=, -=, *=, /=,\nAssignment operators\na = 5\n\n\n\n//=, %=, **=, &=, ^=,\n\na += 5\n\n\n\n\\|=, &lt;&lt;=, &gt;&gt;=",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Python Operators</span>"
    ]
  },
  {
    "objectID": "materials/04-python-operators.html#summary",
    "href": "materials/04-python-operators.html#summary",
    "title": "6  Python Operators",
    "section": "6.12 Summary",
    "text": "6.12 Summary\nUse the above tables to find operators you can use in python. Operators can make code more concise and readable, and can be intuitive to those not familiar with python functions. On the other hand operators can make code less readable and understandable in some situations when compared to utilising functions. Operators also cannot generally be passed as arguments into higher order functions. Operators behave differently on different data types. Try using the * operator to multiply two integers, and to multiply a string by an integer. We will use operators more in the next sections.\n\n\n\n\n\n\nKey Points\n\n\n\n\nPython is rich in operators\nOperators can behave differently when used with different data types and structures\nOperators are ordered in precedence in code in the same way as in mathematics",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Python Operators</span>"
    ]
  },
  {
    "objectID": "materials/05-working-with-numerical-data-types-and-strings.html",
    "href": "materials/05-working-with-numerical-data-types-and-strings.html",
    "title": "7  Working with Numerical Data Types and Strings",
    "section": "",
    "text": "7.1 Working with Numerical Data Types\nUse the exercises below to test your familiarity with operators and working with numerical data types. Here we will use the sys module that ships with python. All we need to do is add the following at the start of our Jupyter notebook:\nWe will be using the sys.getsizeof() function:",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Working with Numerical Data Types and Strings</span>"
    ]
  },
  {
    "objectID": "materials/05-working-with-numerical-data-types-and-strings.html#working-with-numerical-data-types",
    "href": "materials/05-working-with-numerical-data-types-and-strings.html#working-with-numerical-data-types",
    "title": "7  Working with Numerical Data Types and Strings",
    "section": "",
    "text": "import sys\n\nvariable = 3\nsys.getsizeof(variable)\n\n\n\n\n\n\nExercise 1 - Assigning variables\n\n\n\n\n\n\nLevel: \na = 10\nb = 200.5\nc = 5 + 8j\nd = 3\ne = 4.0\nf = 0\ng = 100\nWhat are the data types of each variable and what is the size of each variable in memory. What are your observations?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nimport sys\nprint(\"a:\")\na = 10\nprint(type(a))\nprint(sys.getsizeof(a))\n\nprint(\"b:\") \nb  = 200.5\nprint(type(b))\nprint(sys.getsizeof(b))\n\nprint(\"c:\")\nc = 5 + 8j\nprint(type(c))\nprint(sys.getsizeof(c))\n\nprint(\"d:\")\nd = 3\nprint(type(d))\nprint(sys.getsizeof(d))\n\nprint(\"e:\")\ne = 4.0\nprint(type(e))\nprint(sys.getsizeof(e))\n\nprint(\"f:\")\nf = 0\nprint(type(f))\nprint(sys.getsizeof(f))\n\nprint(\"g:\")\ng = 10000000000\nprint(type(g))\nprint(sys.getsizeof(g))\nOutput:\na:\n&lt;class 'int'&gt;\n28\nb:\n&lt;class 'float'&gt;\n24\nc:\n&lt;class 'complex'&gt;\n32\nd:\n&lt;class 'int'&gt;\n28\ne:\n&lt;class 'float'&gt;\n24\nf:\n&lt;class 'int'&gt;\n24\ng:\n&lt;class 'int'&gt;\n32\nA key point is that integers vary in size, and can be larger than floats which are always 24 bytes. (Try finding the size of a very very large integer and the corresponding float). You can look up how integers and floats in python are stored in memory. Complex numbers are not used commonly, but in this case it is 32 bytes. You can look up more information about this if you are interested.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 2 - Arithmetic Operations on Given Variables\n\n\n\n\n\n\nLevel: \n\n7.1.1 Arithmetic Operations on Given Variables\nGiven the variables, what will be the results of the following arithmetic operations?\n\nWhat is the result of adding the integer values a and d?\nWhat is the product of b and e?\nWhat is the combined result of adding a, b, and e?\nWhat is the difference when subtracting c from b?\nWhat is the exponentiation of d raised to the power of e?\n\nIn each case print the type and size\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nans_1 = a + d\ntype_ans_1 = type(ans_1)\nsize_ans_1 = sys.getsizeof(ans_1)\nans_2 = b * e\ntype_ans_2 = type(ans_2)\nsize_ans_2 = sys.getsizeof(ans_2)\nans_3 = a + b + e\ntype_ans_3 = type(ans_3)\nsize_ans_3 = sys.getsizeof(ans_3)\nans_4 = b - c\ntype_ans_4 = type(ans_4)\nsize_ans_4 = sys.getsizeof(ans_4)\nans_5 = d ** e\ntype_ans_5 = type(ans_5)\nsize_ans_5 = sys.getsizeof(ans_5)\n\nprint('ans_1:', ans_1, type_ans_1, size_ans_1)\nprint('ans_2:', ans_2, type_ans_2, size_ans_2)\nprint('ans_3:', ans_3, type_ans_3, size_ans_3)\nprint('ans_4:', ans_4, type_ans_4, size_ans_4)\nprint('ans_5:', ans_5, type_ans_5, size_ans_5)\noutput:\nans_1: 13 &lt;class 'int'&gt; 28\nans_2: 802.0 &lt;class 'float'&gt; 24\nans_3: 214.5 &lt;class 'float'&gt; 24\nans_4: (195.5-8j) &lt;class 'complex'&gt; 32\nans_5: 81.0 &lt;class 'float'&gt; 24\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 3 - Relational Operations on Given Variables\n\n\n\n\n\n\nLevel: \nUsing relational operators, determine the following comparisons:\n\nIs a equal to the sum of d and e?\nIs b greater than a multiplied by d?\nIs e less than b but greater than d?\nDoes the absolute value of c equal 10?\nIs d less than or equal to the average of a and b?\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nans_1 = a == d + e\nans_2 = b &gt; a * d\nans_3 = e &lt; b and e &gt; d\nans_4 = abs(c) == 10\nans_5 = d &lt;= ((a + b) / 2)\nprint('ans_1:', ans_1)\nprint('ans_2:', ans_2)\nprint('ans_3:', ans_3)\nprint('ans_4:', ans_4)\nprint('ans_5:', ans_5)\noutput:\nans_1: False\nans_2: True\nans_3: True\nans_4: False\nans_5: True\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 4 - Logical Operations on Given Variables\n\n\n\n\n\n\nLevel: \nUse logical operators to evaluate the following conditions:\n\nIs a less than b and d less than e?\nIs it false that b is equal to 20.5?\nIs either a less than d or c equal to 5 + 7j?\nIs b greater than a, and is d equal to 3?\nIs it true that either e is equal to 4, or c is equal to 5 + 7j?\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nans_1 = a &lt; b and d &lt; e\nans_2 = not (b == 20.5)\nans_3 = a &lt; d or c == 5 + 7j\nans_4 = b &gt; a and d == 3\nans_5 = (e == 4) or (c == 5 + 7j)\n\nprint('ans_1:', ans_1)\nprint('ans_2:', ans_2)\nprint('ans_3:', ans_3)\nprint('ans_4:', ans_4)\nprint('ans_5:', ans_5)\nOutput:\nans_1: True\nans_2: True\nans_3: False\nans_4: True\nans_5: True\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 5 - Assignment Operations on Variable a\n\n\n\n\n\n\nLevel: \nUse assignment operators to modify the value of a, and then find the new results:\n\nIncrement a by d.\nSubtract e from the new a.\nMultiply the new a by b.\nDivide the new a by d.\nRaise the new a to the power of e.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\na += d\nprint('ans_1:', a)\na -= e\nprint('ans_2:', a)\na *= b\nprint('ans_3:', a)\na /= d\nprint('ans_4:', a)\na **= e\nprint('ans_5:', a)\n\nsize_a = sys.getsizeof(a)\ntype_a = type(a)\nprint(size_a)\nprint(type_a)\nOutput:\nans_1: 13\nans_2: 9.0\nans_3: 1804.5\nans_4: 601.5\nans_5: 130900868105.0625\n24\n&lt;class 'float'&gt;",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Working with Numerical Data Types and Strings</span>"
    ]
  },
  {
    "objectID": "materials/05-working-with-numerical-data-types-and-strings.html#string-exercises",
    "href": "materials/05-working-with-numerical-data-types-and-strings.html#string-exercises",
    "title": "7  Working with Numerical Data Types and Strings",
    "section": "7.2 String Exercises",
    "text": "7.2 String Exercises\n\nStrings are immutable, meaning once created they cannot be changed.\nStrings are also indexed, allowing access to individual characters and sections (slicing). Indexing with python starts with 0.\nStrings can be concatenated and repeated using operators\nEscape character \\ can be used to include characters like quotation marks\nPython has functions known as string methods inbuilt for string manipulation\nf-strings allow you to embed expressions inside string literals using {} brackets.\n\nFind Examples below: Using indexing to extract Characters\ndna_sequence = \"ACGTAG\"\nprint(dna_sequence[1])\nOutput:\nC\nSlicing Sections\ndna_sequence = \"ACGTAG\"\nprint(dna_sequence[0:4])\nOutput:\nACGT\nConcatenation\nfragment1 = \"AGCT\"\nfragment2 = \"TGCA\"\ncombined_sequence = fragment1 + fragment2\nprint(combined_sequence)\nOutput:\nAGCTTGCA\nRepetition\nrepeated_sequence = \"A\" * 5\nprint(repeated_sequence)\nOutput:\nAAAAA\nEscape Characters\ndna_info = \"The sequence is: \\\"ACGTAG\\\"\"\nprint(dna_info)\nOutput:\nThe sequence is: \"ACGTAG\"\nString Methods\ndna_sequence = \"atcggta\"\nprint(dna_sequence.upper())\nOutput:\nATCGGTA\nOther mathods can be found at: https://www.w3schools.com/python/python_ref_string.asp\nf-strings\nrganism = \"E. coli\"\ngene_count = 4000\ninfo = f\"The organism {organism} has approximately {gene_count} genes.\"\nprint(info)\nOutput:\nThe organism E. coli had approximately 4000 genes\nOther mathods can be found at: https://www.w3schools.com/python/python_ref_string.asp\n\n\n\n\n\n\nExercise 6 - String Exercise: DNA Sequence Manipulation\n\n\n\n\n\n\nLevel: \n\nCreate a DNA Sequence: Start by creating a string that represents a DNA sequence. For this exercise, use the sequence atcgtagc.\nAccess Specific Bases: Retrieve the first and third bases of the DNA sequence using indexing.\nSlice the Sequence: Slice the DNA sequence to get the first five bases.\nConcatenate a New Fragment: Create a new fragment ggcta and concatenate it to the original DNA sequence.\nRepeat a Base: Create a string that consists of the base a repeated 10 times.\nCombine with Repeated Base: Add the repeated base to the combined sequence to produce a final_sequence.\nConvert to Uppercase: Ensure the final_sequence is in uppercase.\nFormat the Output: Use an f-string to create a descriptive output that includes the original sequence, the sliced part, the combined sequence, the repeated base, and the final sequence.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Step 1: Create a DNA sequence\ndna_sequence = \"atcgtagc\"\n\n# Step 2: Access specific bases\nfirst_base = dna_sequence[0]   # a\nthird_base = dna_sequence[2]    # c\n\n# Step 3: Slice the sequence\nsliced_sequence = dna_sequence[0:5]  # atcgt\n\n# Step 4: Concatenate a new fragment\nnew_fragment = \"ggcta\"\ncombined_sequence = dna_sequence + new_fragment  # atcgtagcggcta\n\n# Step 5: Repeat a base\nrepeated_base = \"a\" * 10  # aaaaaaaaaa\n\n# Step 6: Combine with repeated base\nfinal_sequence = combined_sequence + repeated_base  # atcgtagcggctaaaaaaaaaa\n\n# Step 7: Convert to uppercase\nupper_final_sequence = final_sequence.upper()  # ATCGTAGCGGCTAAAAAAAAAA\n\n# Step 8: Format the output\noutput = (f\"Original DNA Sequence: {dna_sequence}\\n\"\n          f\"First Base: {first_base}\\n\"\n          f\"Third Base: {third_base}\\n\"\n          f\"Sliced Sequence (first 5 bases): {sliced_sequence}\\n\"\n          f\"Combined Sequence: {combined_sequence}\\n\"\n          f\"Repeated Base (a): {repeated_base}\\n\"\n          f\"Final Sequence (in uppercase): {upper_final_sequence}\")\n\n# Print the output\nprint(output)\nOutput:\nOriginal DNA Sequence: atcgtagc\nFirst Base: a\nThird Base: c\nSliced Sequence (first 5 bases): atcgt\nCombined Sequence: atcgtagcggcta\nRepeated Base (a): aaaaaaaaaa\nFinal Sequence (in uppercase): ATCGTAGCGGCTAAAAAAAAAAA",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Working with Numerical Data Types and Strings</span>"
    ]
  },
  {
    "objectID": "materials/05-working-with-numerical-data-types-and-strings.html#summary",
    "href": "materials/05-working-with-numerical-data-types-and-strings.html#summary",
    "title": "7  Working with Numerical Data Types and Strings",
    "section": "7.3 Summary",
    "text": "7.3 Summary\nAfter these exercises you should be able to work with numerical data and strings in Python!\n\n\n\n\n\n\nKey Points\n\n\n\n\nIt is easy to use operators and functions to work both with strings and numbers in python\nTracking memory usage and data type can be important",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Working with Numerical Data Types and Strings</span>"
    ]
  },
  {
    "objectID": "materials/06--working-with-composite-data-types.html",
    "href": "materials/06--working-with-composite-data-types.html",
    "title": "8  Working with Composite Data Types",
    "section": "",
    "text": "8.1 Overview of Composite data types\nIn Python, composite data types allow you to store multiple values in a single variable. They can hold a collection of items, which can be of different data types. The main composite data types in Python are:\nLists\nTuples\nDictionaries\nSets\nExample Initialization and Differences:\nLet’s initialize one of each composite data type with a list of 10 animals, and then demonstrate some of the main differences.\nRemember the key differences:\nMutability\nOrder\nDuplicates",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Working with Composite Data Types</span>"
    ]
  },
  {
    "objectID": "materials/06--working-with-composite-data-types.html#overview-of-composite-data-types",
    "href": "materials/06--working-with-composite-data-types.html#overview-of-composite-data-types",
    "title": "8  Working with Composite Data Types",
    "section": "",
    "text": "Definition: Ordered, mutable collections that allow duplicate items.\nSyntax: Defined using square brackets [].\n\n\n\nDefinition: Ordered, immutable collections that can also contain duplicates.\nSyntax: Defined using parentheses ().\n\n\n\nDefinition: Unordered collections of key-value pairs, where each key is unique and must be immutable.\nSyntax: Defined using curly braces {} and using a colon : to separate keys from values.\n\n\n\nDefinition: Unordered collections of unique items.\nSyntax: Defined using curly braces {} or the set() function.\n\n\n\n# Initialize a list of animals\nanimal_list = [\"Dog\", \"Cat\", \"Elephant\", \"Lion\", \"Tiger\", \"Giraffe\", \"Zebra\", \"Monkey\", \"Snake\", \"Rabbit\"]\n\n# Initialize a tuple of animals\nanimal_tuple = (\"Dog\", \"Cat\", \"Elephant\", \"Lion\", \"Tiger\", \"Giraffe\", \"Zebra\", \"Monkey\", \"Snake\", \"Rabbit\")\n\n# Initialize a dictionary of animals with their classifications\nanimal_dict = {\n    \"Dog\": \"Mammal\",\n    \"Cat\": \"Mammal\",\n    \"Elephant\": \"Mammal\",\n    \"Lion\": \"Mammal\",\n    \"Tiger\": \"Mammal\",\n    \"Giraffe\": \"Mammal\",\n    \"Zebra\": \"Mammal\",\n    \"Monkey\": \"Mammal\",\n    \"Snake\": \"Reptile\",\n    \"Rabbit\": \"Mammal\"\n}\n\n# Initialize a set of animals\nanimal_set = {\"Dog\", \"Cat\", \"Elephant\", \"Lion\", \"Tiger\", \"Giraffe\", \"Zebra\", \"Monkey\", \"Bear\", \"Rabbit\"}\n\n# Show differences between data types\nprint(\"Original List:\", animal_list)\nprint(\"Original Tuple:\", animal_tuple)\nprint(\"Original Dictionary:\", animal_dict)\nprint(\"Original Set:\", animal_set)\n\n# Mutability Demonstration\n# Modifying the list (mutable)\nanimal_list[0] = \"Wolf\"  # Change \"Dog\" to \"Wolf\"\nprint(\"Modified List:\", animal_list)\n\n# Attempting to modify the tuple (immutable)\nanimal_tuple[0] = \"Wolf\"  \n# This will raise an error\n\n# Adding a new key-value pair to the dictionary (mutable)\nanimal_dict[\"Fox\"] = \"Mammal\"\nprint(\"Modified Dictionary:\", animal_dict)\n\n# Attempting to add a duplicate to the set (will be ignored)\nanimal_set.add(\"Dog\")  # This will not change the set\nprint(\"Modified Set (after trying to add 'Dog'):\", animal_set)\n\n\n\nLists: Mutable - items can be changed or updated.\nTuples: Immutable - once defined, items cannot be changed.\nDictionaries: Mutable - keys and values can be added or updated.\nSets: Mutable - can add or remove items, but cannot contain duplicates.\n\n\n\nLists and Tuples: Ordered collections (the order of elements matters).\nDictionaries: Maintains insertion order as of Python 3.7.\nSets: Unordered - no guaranteed order of elements\n\n\n\nLists and Tuples: Allow duplicates.\nDictionaries: Keys must be unique, but values can be duplicated.\nSets: Do not allow duplicates.",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Working with Composite Data Types</span>"
    ]
  },
  {
    "objectID": "materials/06--working-with-composite-data-types.html#composite-data-types-and-memory-management",
    "href": "materials/06--working-with-composite-data-types.html#composite-data-types-and-memory-management",
    "title": "8  Working with Composite Data Types",
    "section": "8.2 Composite Data types and Memory Management",
    "text": "8.2 Composite Data types and Memory Management\nThe way memory is managed is important. When coding we want to minimise memory use. One way of doing this is by not making needless duplications.\nUnderstanding the behaviour of objects and how they are copied is crucial for managing memory and ensuring that your programs behave as expected. This is even more crucial when working with composite data types.\n\nIn the next sections we will work with different composite data types and investigate deep and shallow copies.\n\nWe will use the id() function and lists to demonstrate this.\nThe id() function returns the unique identifier (memory address) of an object. This is an integer guaranteed to be unique and constant for the object during its lifetime.\n\n\n\n\n\n\nExercise 1 - Equal Variables\n\n\n\n\n\n\nLevel: \nWhen you assign the value of one variable to another, what happens? i.e.\na = 10\nb = a\nwhat are the unique memory identifiers returned for a and b? If you changed variable ‘a’ what would happen?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nid(a)\nid(b)\nAs you can see if you run the above code, the two variable names ‘a’ and ‘b’ point to the same object in memory. As integers are immutable, if you change ‘a’, this will be assigned a new object in memory. The variable ‘b’ will remain the same and point to the original memory object.\nAs we will see below, with mutable composite data types like lists, things can become more complex.\n\n\n\n\n\n\n\n\nPython Object Behavior: Objects and References\nIn Python, variables are references to objects. When you assign a variable to another variable, you’re copying the reference, not the actual object.",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Working with Composite Data Types</span>"
    ]
  },
  {
    "objectID": "materials/06--working-with-composite-data-types.html#working-with-lists-in-python",
    "href": "materials/06--working-with-composite-data-types.html#working-with-lists-in-python",
    "title": "8  Working with Composite Data Types",
    "section": "8.3 Working with Lists in Python",
    "text": "8.3 Working with Lists in Python\nLists in Python are versatile and support various operations that allow you to manipulate and interact with the data they contain. Below are some common operations you can perform on lists.\nAccessing Elements\nYou can access list elements using indexing (zero-based).\nfirst_element = my_list[0]  # 1\nlast_element = my_list[-1]   # 5\nSlicing a List\nYou can retrieve a portion of a list using slicing.\nsub_list = my_list[1:4]  # [2, 3, 4]\nAdding Elements\nAppend: Add an element to the end of the list.\nmy_list.append(6)  # [1, 2, 3, 4, 5, 6]\nInsert: Insert an element at a specific index.\nmy_list.insert(2, 2.5)  # [1, 2, 2.5, 3, 4, 5, 6]\nRemoving Elements\nRemove: Remove the first occurrence of a specified value.\nmy_list.remove(2.5)  # [1, 2, 3, 4, 5, 6]\nPop: Remove and return an element at a specified index (default is the last element).\nlast_item = my_list.pop()  # list is now [1, 2, 3, 4, 5]\nModifying Elements\nYou can change the value of an element using its index.\nmy_list[1] = 20  # [1, 20, 3, 4, 5]\nExtending a List\nYou can add multiple elements to the end of the list using extend().\nmy_list.extend([6, 7, 8])  # [1, 20, 3, 4, 5, 6, 7, 8]\nSorting a List\nSort the list in ascending order.\nmy_list.sort()  # [1, 3, 4, 5, 6, 7, 8, 20]\nReversing a List\nYou can reverse the order of elements in a list.\nmy_list.reverse()  # [20, 8, 7, 6, 5, 4, 3, 1]\nFinding the Length\nGet the number of elements in the list.\nlength = len(my_list)  # 8\nNumeric operators e.g. Append multiple repeats\nmy_list * 2  # [20, 8, 7, 6, 5, 4, 3, 1, 20, 8, 7, 6, 5, 4, 3, 1]\nConclusion\nLists are a fundamental data structure in Python that allow for a variety of operations. By understanding these operations, you can effectively manage and manipulate data in your programs.\n\n\n\n\n\n\nExercise 2 - List Exercise: part 1\n\n\n\n\n\n\nLevel: \n\nCreate a list with 5 letters a-e, named letters\nInvestigate the unique identifiers of the list and the members of the list.\nAssign letter2 to letters (letters2 = letters)\nChange the 3rd letter in letters to f and sort the letters alphabetically\nWhat happens to letters2?\nuse slicing to take the middle three letters to the variable letters_subset\nWhat do you notice about the unique identifiers of letters_subset and the members of the list?\nUse the inbuilt list copy function to create a copy of letters named letters_copy letters_copy = letters.copy()\nWhat are the identifiers now?\nIf I modified a variable in letters_copy would letters change?\nDo you think letters_copy is a shallow or deep copy and why?\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n\n# 1. Create a list with 5 letters a-e, named letters\nletters = ['a', 'b', 'c', 'd', 'e']\n\n# 2. Investigate the unique identifiers of the list and the members of the list.\nid_letters = id(letters)  # Get the ID of the list\nid_member_1 = id(letters[0])  # ID of 'a'\nid_member_2 = id(letters[1])  # ID of 'b'\nid_member_3 = id(letters[2])  # ID of 'c'\nid_member_4 = id(letters[3])  # ID of 'd'\nid_member_5 = id(letters[4])  # ID of 'e'\n\nprint(f'ID of letters:{id_letters}')\nprint(f'IDs of members: {id_member_1}, {id_member_2}, {id_member_3}, {id_member_4}, {id_member_5}')\n# each member has a unique identifier and is an object as is the list\n\n# 3. Assign letter2 to letters (letters2 = letters)\nletters2 = letters  # Assign letters to letters2\n\n# 4. Change the 3rd letter in letters to `f` and sort the letters alphabetically\nletters[2] = 'f'  # Change the 3rd letter\nletters.sort()    # Sort the letters\nprint(letters)    # Output: ['a', 'b', 'd', 'e', 'f']\n\n# 5. What happens to letters2?\n# letters2 will reflect the changes made to letters because both reference the same list object.\nprint(f'letters2 after modification: {letters2}')  # Output: ['a', 'b', 'd', 'e', 'f']\n\n# 6. Use slicing to take the middle three letters to the variable letters_subset\nletters_subset = letters[1:4]  # This will take letters at index 1, 2, and 3\nprint(letters_subset)  # Output: ['b', 'd', 'e']\n\n# 7. What do you notice about the unique identifiers of letters_subset and the members of the list?\n# letters_subset has a different identifier than letters, but its members share identifiers with the corresponding members in letters.\n\n# 8. Use the inbuilt list copy function to create a copy of letters named letters_copy\nletters_copy = letters.copy()  # Create a copy of letters\n\n# 9. What are the identifiers now?\nid_letters_copy = id(letters_copy)  # Get the ID of the copied list\nid_member_copy_1 = id(letters_copy[0])  # ID of 'a'\nid_member_copy_2 = id(letters_copy[1])  # ID of 'b'\nid_member_copy_3 = id(letters_copy[2])  # ID of 'd'\nid_member_copy_4 = id(letters_copy[3])  # ID of 'e'\nid_member_copy_5 = id(letters_copy[4])  # ID of 'f'\n\nprint(f\"ID of letters_copy: {id_letters_copy}\")\nprint(f\"IDs of members in letters_copy: {id_member_copy_1}, {id_member_copy_2}, {id_member_copy_3}, {id_member_copy_4}, {id_member_copy_5}\")\n\n# 10. If I modified a variable in letters_copy would letters change?\n# No, modifying letters_copy will not affect letters because letters_copy is a separate list.\n\n# 11. Do you think letters_copy is a shallow or deep copy and why?\n# letters_copy is a shallow copy because it copies the references to the objects in the original list rather than the objects themselves.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 3 - List Exercise: Part 2\n\n\n\n\n\n\nLevel: \n\nTry changing the second element of the letters list to the list [‘n’ , ‘w’] to create a nested list. Look at the identifiers\nmake a copy called newletters_copy.\nBefore doing any computing - what do you think would happen if I changed letters_copy[1][1] to \"s\" ?\nTry it and see what happens. Think about what it means in terms of deep and shallow copies. How would you create a deep copy?\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Original letters list\nletters = ['a', 'b', 'c', 'd', 'e']\n\n# 1 Change the second element of the letters list to a nested list\nletters[1] = ['n', 'w']  # Now letters is ['a', ['n', 'w'], 'c', 'd', 'e']\n\n# Check the identifiers of the modified letters list and its elements\nid_letters = id(letters)  # Get the ID of the outer list\nid_second_element = id(letters[1])  # ID of the nested list ['n', 'w']\nprint(f'id_letters{id_letters}')\nprint(\"second element id\", id_second_element)\n#All the other ID's stay the same\n\n#could also see:\n#id_first_nested_element = id(letters[1][0])  # ID of 'n'\n#id_second_nested_element = id(letters[1][1])  # ID of 'w'\nprint(f'ID of the first element in the nested list: {id_first_nested_element}')\nprint(f'ID of the second element in the nested list: {id_second_nested_element}')\n\n# 2. Make a copy of letters called newletters_copy\nnewletters_copy = letters.copy()  \n\n3. Predict what will happen if we change newletters_copy[1][1] to “s” Since newletters_copy[1] will be a reference to the same nested list as letters[1], changing newletters_copy[1][1] will also change letters[1][1]. You can check this is the case by looking at the identifiers\n# 4 Perform the change\nnewletters_copy[1][1] = \"s\"\n\n# Check the modified lists\nprint(f\"Modified letters: {letters}\")  # Expect: ['a', ['n', 's'], 'c', 'd', 'e']\nprint(f\"Modified newletters_copy: {newletters_copy}\")  # Expect: ['a', ['n', 's'], 'c', 'd', 'e']\n\nExplanation This shows that when you change a nested element in a shallow copy, it affects the original list because both lists reference the same nested object.",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Working with Composite Data Types</span>"
    ]
  },
  {
    "objectID": "materials/06--working-with-composite-data-types.html#shallow-copy-verses-deep-copy",
    "href": "materials/06--working-with-composite-data-types.html#shallow-copy-verses-deep-copy",
    "title": "8  Working with Composite Data Types",
    "section": "8.4 Shallow Copy verses Deep Copy",
    "text": "8.4 Shallow Copy verses Deep Copy\nShallow Copy A shallow copy creates a new object but inserts references into it to the objects found in the original. This means that if the original object contains other mutable objects (like lists or dictionaries), those nested objects are not copied; they are shared between the original and the copied object.\nDeep Copy A deep copy creates a new object and recursively adds copies of nested objects found in the original. This means that all levels of the object hierarchy are duplicated, and changes made to the copied object do not affect the original.\nYou can create a deep copy using the copy module:\nimport copy\n\noriginal = [1, 2, [3, 4]]\ndeep_copied = copy.deepcopy(original)\nMemory Usage\nShallow Copy: Uses less memory as it only copies references.\nDeep Copy: Uses more memory because it creates full copies of all objects.\nPerformance\nShallow Copy: Faster due to less overhead in copying.\nDeep Copy: Slower because of the recursive copying of all elements.\nOverview\nUnderstanding shallow and deep copies is essential for effective memory management and to avoid unintended side effects when working with mutable objects in Python. Choose the appropriate type of copy based on whether you need to maintain shared references to nested objects or require complete independence between copies.",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Working with Composite Data Types</span>"
    ]
  },
  {
    "objectID": "materials/06--working-with-composite-data-types.html#working-with-dictionaries",
    "href": "materials/06--working-with-composite-data-types.html#working-with-dictionaries",
    "title": "8  Working with Composite Data Types",
    "section": "8.5 Working with Dictionaries",
    "text": "8.5 Working with Dictionaries\nDictionaries are efficient ways to manage and access data. Keys must be immutable, but values can be anything.\nExamples are presented below:\ngene_info = {\n    \"gene\": \"BRCA1\",\n    \"sequence\": \"ATCGGCCGTAAGCTAGCTAGCTAGC\",\n    \"function\": \"DNA repair\",\n    \"organism\": \"Homo sapiens\"\n}\nAccessing Values\nYou can access a value by referring to its key.\nprint(\"Gene Name:\", gene_info[\"gene\"])  # Output: Gene Name: BRCA1\nAdding a New Key-Value Pair\nYou can add new key-value pairs to a dictionary.\ngene_info[\"chromosome\"] = \"17\"\nprint(\"Updated gene info dictionary:\", gene_info)\nModifying Existing Values\nYou can change the value of an existing key.\ngene_info[\"function\"] = \"DNA repair and regulation\"\nprint(\"Updated function:\", gene_info[\"function\"])  # Output: Updated function: DNA repair and regulation\nRemoving a Key-Value Pair\nUse the del statement to remove a key-value pair.\ndel gene_info[\"organism\"]\nprint(\"After removing organism:\", gene_info)\nUsing get() Method\nUse the get() method to avoid KeyError if the key does not exist.\nchromosome = gene_info.get(\"chromosome\", \"Not available\")\nprint(\"Chromosome:\", chromosome)  # Output: Chromosome: 17",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Working with Composite Data Types</span>"
    ]
  },
  {
    "objectID": "materials/06--working-with-composite-data-types.html#benchmarking",
    "href": "materials/06--working-with-composite-data-types.html#benchmarking",
    "title": "8  Working with Composite Data Types",
    "section": "8.6 Benchmarking",
    "text": "8.6 Benchmarking\nAs there are often different methods to implement code. It is important to test the performance of different code through Benchmarking.\nMemory use and how fast your code runs are two things that can be optimised.\n\ncprofiler and timeit are both modules that can be used. Here we will use timeit to compare the dictionaries and lists.\nimport timeit\n\ngene_info_list = [\"BRCA1\", \"ATCGGCCGTAAGCTAGCTAGCTAGC\", \"DNA repair\", \"Homo sapiens\", \"17\"]\ngene_info_dictionary = {\n    \"gene\": \"BRCA1\",\n    \"sequence\": \"ATCGGCCGTAAGCTAGCTAGCTAGC\",\n    \"function\": \"DNA repair\",\n    \"organism\": \"Homo sapiens\",\n    \"chromosome\": \"17\"\n}\n\n# Define functions to access list and dictionary elements - we will go over this later\n\ndef access_list_element():\n    gene_info_list[1]  # Accessing element using lists\n\ndef access_dictionary_element():\n    gene_info_dictionary[\"sequence\"]  # Accessing element using dictionaries\n\n# Measure execution time\nexecution_time_list = timeit.timeit(access_list_element, number=100000)\nexecution_time_dictionary = timeit.timeit(access_dictionary_element, number=100000)\n\nprint(\"execution time list\", execution_time_list)\nprint(\"execution time dictionary\", execution_time_dictionary)\n\nOutput\nexecution time list 0.013154594002116937\nexecution time dictionary 0.009285816002375213\nTry it yourself! *For extra reading you can read about optimising compilers, how they apply to python and other coding languages, and what they can and cannot do.",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Working with Composite Data Types</span>"
    ]
  },
  {
    "objectID": "materials/06--working-with-composite-data-types.html#sets-and-tuples",
    "href": "materials/06--working-with-composite-data-types.html#sets-and-tuples",
    "title": "8  Working with Composite Data Types",
    "section": "8.7 Sets and tuples",
    "text": "8.7 Sets and tuples\nAlthough we won’t go through sets and tuples in detail, information can be found here:\n\nhttps://www.w3schools.com/python/python_sets.asp\nhttps://www.w3schools.com/python/python_tuples.asp",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Working with Composite Data Types</span>"
    ]
  },
  {
    "objectID": "materials/06--working-with-composite-data-types.html#summary",
    "href": "materials/06--working-with-composite-data-types.html#summary",
    "title": "8  Working with Composite Data Types",
    "section": "8.8 Summary",
    "text": "8.8 Summary\nComposite data types are data structures that group multiple elements, potentially of different types, into a single unit. Examples include arrays, lists, tuples, and records (like structs or objects). They allow for more complex data organization by storing and managing collections of related information. There are multiple ways to implement things and as we have seen benchmarking can be an effective way to choose the best method.\n\n\n\n\n\n\nKey Points\n\n\n\n\nDifferent composite data types have different properties\nBenchmarking and understanding the different properties of the data types can be used to choose the best approach",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Working with Composite Data Types</span>"
    ]
  },
  {
    "objectID": "materials/07-conditionals-and-loops-in-python.html",
    "href": "materials/07-conditionals-and-loops-in-python.html",
    "title": "9  Conditionals and Loops in Python",
    "section": "",
    "text": "9.1 Conditionals\nConditionals in Python allow you to execute different blocks of code based on conditions with boolean outputs. This is mainly done using if, elif, and else statements.\nif Statement:\nThe if statement evaluates a condition which has returned a boolean (True or False). If the condition is True, the block of code inside the if statement is executed.\nelif Statement:\nThe elif (short for “else if”) statement allows you to check multiple conditions. It follows an if statement and is executed if the previous conditions were False and its own condition is True.\nelse Statement:\nThe else statement is used to execute a block of code if none of the preceding if or elif conditions were True.\nSyntax\nNote the colon and indentation used in the above example\nHere is a very simple example of using conditionals:\nWith very simple conditions, python has a shorthand that is useful. You can do things like:\nOperators\nThe operators are a key tool when using conditional statements in python. Remind yourself about them and their order of precedence.",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Conditionals and Loops in Python</span>"
    ]
  },
  {
    "objectID": "materials/07-conditionals-and-loops-in-python.html#conditionals",
    "href": "materials/07-conditionals-and-loops-in-python.html#conditionals",
    "title": "9  Conditionals and Loops in Python",
    "section": "",
    "text": "if condition:\n    print(x) # Code to execute if condition is True\nelif another_condition:\n    print(y) # Code to execute if first condition is False and another_condition is True\nelse:\n    print(z) # Code to execute if all conditions are False\n\n\n\nIndentation is also used to nest conditionals and loops in python, and incorrect indentation is a common cause for errors.\n\n\ntemperature = 25\n\nif temperature &gt; 30:\n    print(\"It's a hot day.\")\n    #The program checks if the temperature is greater than 30. If it is, it prints \"It's a hot day.\"\nelif temperature &lt; 10:\n    print(\"It's a cold day.\")\n    #If the first condition is False, it checks if the temperature is less than 10. If this condition is True, it prints \"It's a cold day.\"\nelse:\n    print(\"It's a pleasant day.\")\n    #If both conditions are False, the else block executes and prints \"It's a pleasant day.\"\n\nprint(\"it's a hotday\") if temperature &gt; 30 else (print(\"it's a cold day\") if temperature &lt; 10 else print(\"it's a pleasent day\"))\n# these are known as ternary operators - there is no elif\n\n\n\n\n\n\n\n\nExercise 1 - Discussion: Operators\n\n\n\n\n\n\nLevel: \nWhich types of operators are most useful when using conditional statements in Python?\n\n\n\n\n\n\n\n\n\n\nExercise 2 - examining conditional statements\n\n\n\n\n\n\nLevel: \n\nWhat do the following if statements do?\nHow can you write complex conditions and make your code legible?\n\nSome actual examples from my (not perfect) code:\nif (len(x[0]) == 2) and not any(x % 10 in {0, 9} for x in x[0]):\n    if (\n        (coordcolumnchoice[0] == (1,1) and coordinateM[0,0] in x[0] and coordinateM[1,1] in x[0]) or\n        (coordcolumnchoice[0] == (1,1) and coordinateM[1,0] in x[0] and coordinateM[0,1] in x[0]) or\n        (coordcolumnchoice[0] == (1,0) and coordinateM[1,0] in x[0] and coordinateM[0,0] in x[0]) or\n        (coordcolumnchoice[0] == (1,0) and coordinateM[1,1] in x[0] and coordinateM[0,1] in x[0])\n      ):\nHow might the second example be clearer if I was writing it again?",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Conditionals and Loops in Python</span>"
    ]
  },
  {
    "objectID": "materials/07-conditionals-and-loops-in-python.html#try-and-except-in-python",
    "href": "materials/07-conditionals-and-loops-in-python.html#try-and-except-in-python",
    "title": "9  Conditionals and Loops in Python",
    "section": "9.2 try and except in Python",
    "text": "9.2 try and except in Python\nIn Python, try and except blocks are used for handling exceptions, which are errors that can occur during program execution. This mechanism allows developers to anticipate potential errors, provide alternate code to handle them, and prevent the program from crashing. Here’s how it works:\ntry Block:\nThe code that might raise an exception is placed inside the try block. If an exception occurs during execution of this block, the rest of the block is skipped, and control is passed to the except block.\nexcept Block:\nThis block contains code that handles the exception. You can specify which exception to catch, or leave it blank to catch any exception. If the exception type matches the one specified in the except block, the code inside it is executed.\nMultiple except Blocks:\nYou can have multiple except blocks to handle different types of exceptions.\nelse Block:\nYou can add an else block after the except block. This block runs if the try block executes without raising an exception.\nfinally Block:\nThe finally block runs regardless of whether an exception was raised or not. It is often used for cleanup actions, like closing files or releasing resources.\nExample\nHere’s a simple example demonstrating the use of try and except:\ntry:\n    # Code that may raise an exception\n    numerator = 10\n    denominator = 0\n    result = numerator / denominator\nexcept ZeroDivisionError:\n    # Handling a specific exception\n    print(\"Error: You cannot divide by zero.\")\nexcept Exception as e:\n    # Handling any other exception\n    print(f\"An unexpected error occurred: {e}\")\nelse:\n    # Executes if no exception occurred\n    print(\"The result is:\", result)\nfinally:\n    # This block runs no matter what\n    print(\"Execution completed.\")\nExplanation of the Example:\ntry:\n\nAttempts to divide numerator by denominator. Since denominator is zero, this raises a ZeroDivisionError.\n\nexcept:\n\nThe first except catches the ZeroDivisionError and prints an error message.\nThe second except would catch any other unexpected exceptions, but it won’t run in this case because the first except handles the error.\n\nelse:\n\nIf there were no exceptions, the else block would print the result.\n\nfinally:\n\nThis block runs at the end of the try/except structure, regardless of whether an exception occurred or not. It’s useful for cleanup actions.\n\nIn this case I might not use the else or finally\nBenefits of Using try and except:\n\nPrevents Crashes: By handling exceptions, you can prevent your program from crashing due to unforeseen errors.\nCleaner Code: It allows for clearer separation of normal code and error handling.\nMore Robust Programs: By anticipating and handling potential errors, your programs can handle unexpected situations better.",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Conditionals and Loops in Python</span>"
    ]
  },
  {
    "objectID": "materials/07-conditionals-and-loops-in-python.html#for-loops-in-python",
    "href": "materials/07-conditionals-and-loops-in-python.html#for-loops-in-python",
    "title": "9  Conditionals and Loops in Python",
    "section": "9.3 for Loops in Python",
    "text": "9.3 for Loops in Python\nfor loops iterate over a sequence (list, tuple, string, dictionary, set, or range) and perform processes. The syntax of a for loop is simple but must be carefully followed, especially with respect to the colon (:) and indentation.\nSyntax\n\nThe for keyword is followed by a variable name (e.g., item) that will take on the value of each element in the sequence.\n\nThe sequence can be a list, tuple, string, or any iterable object.\n\nThe colon (:) indicates the start of the loop block.\n\nThe indented lines that follow the colon are the code that will be executed.\n\nfor item in sequence:\n    print(x) # Code block to execute\nExample:\nanimals = [\"dog\", \"cat\", \"rabbit\", \"elephant\", \"tiger\"]\n\nfor animal in animals:\n    print(f'I have a {animal}.')\nOutput\nI have a dog.\nI have a cat.\nI have a rabbit.\nI have an elephant.\nI have a tiger.",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Conditionals and Loops in Python</span>"
    ]
  },
  {
    "objectID": "materials/07-conditionals-and-loops-in-python.html#using-len-and-range-in-for-loops",
    "href": "materials/07-conditionals-and-loops-in-python.html#using-len-and-range-in-for-loops",
    "title": "9  Conditionals and Loops in Python",
    "section": "9.4 Using len() and range() in for loops",
    "text": "9.4 Using len() and range() in for loops\nIn Python, len() and range() are often used with for loops to control iterations and access elements by their index.\nUsing len()\nThe len() function returns the number of items in an iterable (like a list, tuple, or string). This is useful when you need to loop through each element of a sequence without manually specifying the length.\nUsing range\nThe range() function generates a sequence of numbers, which can be useful for iterating over a sequence with a specified start and end. The syntax is range(start, stop[, step])\n# Loop through the first five integers\nfor num in range(5):\n    print(num)\n\nExamples:\nanimals = [\"dog\", \"cat\", \"rabbit\", \"elephant\"]\n\nfor i in range(len(animals)):            # only 1 value - stop\n    print(f\"Animal at index {i}: {animals[i]}\")\n\nfor i in range(0,len(animals),2):        #start, stop, step\n    print(f\"Animal at index {i}: {animals[i]}\")",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Conditionals and Loops in Python</span>"
    ]
  },
  {
    "objectID": "materials/07-conditionals-and-loops-in-python.html#using-enumerate-in-for-loops",
    "href": "materials/07-conditionals-and-loops-in-python.html#using-enumerate-in-for-loops",
    "title": "9  Conditionals and Loops in Python",
    "section": "9.5 Using enumerate() in for Loops",
    "text": "9.5 Using enumerate() in for Loops\nThe enumerate() function in Python adds a counter to an iterable and returns it as an enumerate object. This is particularly useful when you want to loop through a sequence and keep track of the index of each item without using range().\nSyntax\nThe syntax of enumerate() is as follows:\nenumerate(iterable, start=0)\n\niterable: The sequence (like a list, tuple, or string) you want to iterate over.\nstart: The starting index (default is 0).\n\nExample of enumerate() Here’s a simple example demonstrating how to use enumerate() with a list of animals:\nanimals = [\"dog\", \"cat\", \"rabbit\", \"elephant\"]\n\nfor index, animal in enumerate(animals):\n    print(f\"Animal {index}: {animal}\")\noutput:\nAnimal 0: dog\nAnimal 1: cat\nAnimal 2: rabbit\nAnimal 3: elephant\nBenefits of Using enumerate()\n\nClarity: It makes the code cleaner and more readable by eliminating the need to manually manage the index.\nConvenience: Automatically handles the index tracking for you, reducing the risk of errors.\n\n\n\n\n\n\n\nExercise 3 - Count Nucleotide Occurrences\n\n\n\n\n\n\nLevel: \nGiven a DNA sequence, write a loop to count the occurrences of each nucleotide (A, T, C, G).\nDNA Sequence:\ndna_sequence = \"ATCGATCGATCGATCG\"\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Given DNA sequence\ndna_sequence = \"ATCGATCGATCGATCG\"\n\nInitial Answer\n# Initialize counts\ncount_A = 0\ncount_T = 0\ncount_C = 0\ncount_G = 0\n\n# Count nucleotides\nfor nucleotide in dna_sequence:\n    if nucleotide == 'A':\n        count_A += 1\n    elif nucleotide == 'T':\n        count_T += 1\n    elif nucleotide == 'C':\n        count_C += 1\n    elif nucleotide == 'G':\n        count_G += 1\n\nprint(f\"A: {count_A}, T: {count_T}, C: {count_C}, G: {count_G}\")\n\n\n\n\nWhat exceptions might be generated? - Add an else statement to deal with other characters - Use try and except - what exception cases would this allow you to handle? Remember to follow the indentation pattern\n\n\n\n\n\n\n\n\n\n\nExercise 4 - Make your own for loop\n\n\n\n\n\n\nLevel: \nExercise: Create your own for loop example with a dictionary, using the enumerate() function, try and except, and if statements. Explain what your code does? Discuss in groups how you might improve each other’s code?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nExample answer:\n# Define a dictionary of animals and their respective speeds in km/h\nanimal_speeds = {\n    \"Cheetah\": 120,\n    \"Tortoise\": 0.3,\n    \"Falcon\": \"fast\",  # Intentional error: speed should be a number\n    \"Horse\": 88,\n    \"Elephant\": 40\n}\n\n# Loop through the dictionary using enumerate\nfor index, (animal, speed) in enumerate(animal_speeds.items()):\n    try:\n        # Check if speed is numeric, and if the animal is faster than 50 km/h\n        if speed &gt; 50:\n            print(f\"{index + 1}. {animal} is fast with a maximum speed of {speed} km/h!\")\n        else:\n            print(f\"{index + 1}. {animal} is slow with a maximum speed of {speed} km/h.\")\n    except TypeError:\n        # Handle the case where speed is not a numeric value\n        print(f\"{index + 1}. {animal} has an invalid speed value: {speed}\")\nFor this code, some improvements are:\nanimal_speeds = {\n    \"Cheetah\": 120,\n    \"Tortoise\": 0.3,\n    \"Falcon\": \"fast\",  # Intentional error: speed should be a number\n    \"Horse\": 88,\n    \"Elephant\": 40,\n}\n\nfor index, (animal, speed) in enumerate(animal_speeds.items(), start=1):\n    try:\n        # Check if speed is numeric, and if the animal is faster than 50 km/h\n        if speed &gt; 50:\n            print(f\"{index}. {animal} is fast with a maximum speed of {speed} km/h!\")\n        else:\n            print(f\"{index}. {animal} is slow with a maximum speed of {speed} km/h.\")\n    except TypeError:\n        # Handle the case where speed is not a numeric value\n        print(f\"{index}. {animal} has an invalid speed value: {speed}\")\n\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\noutput:\n\n1. Cheetah is fast with a maximum speed of 120 km/h!\n2. Tortoise is slow with a maximum speed of 0.3 km/h.\n3. Falcon has an invalid speed value: fast\n4. Horse is fast with a maximum speed of 88 km/h!\n5. Elephant is slow with a maximum speed of 40 km/h.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 5 - Edge Cases\n\n\n\n\n\n\nLevel: \nHow would you deal with the following edge case?\nanimal_speeds = {\n    \"Cheetah\": 120,\n    \"Tortoise\": 0.3,\n    \"Falcon\": \"fast\",  # Intentional error: speed should be a number\n    \"Horse\": 88,\n    \"Elephant\": 40,\n    (20,3): 0.5\n}\nThis would run as if there is no problem in the code.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nmaybe add a if Statement?",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Conditionals and Loops in Python</span>"
    ]
  },
  {
    "objectID": "materials/07-conditionals-and-loops-in-python.html#match-statements",
    "href": "materials/07-conditionals-and-loops-in-python.html#match-statements",
    "title": "9  Conditionals and Loops in Python",
    "section": "9.6 match Statements",
    "text": "9.6 match Statements\n\n9.6.1 A newer way of working with conditionals!\nmatch statements (Python 3.10 onwards) allow for structural pattern matching, which is a more powerful and flexible version of if-elif chains. With match, you can compare variables to patterns and handle complex matching scenarios in a clear, concise way, and also directly deconstruct variables!\n\n\n\n\n\n\n\n\nFeature\nif Statements\nmatch Statements\n\n\n\n\nSimplicity for Basic Cases\nEasy for simple comparisons\nSimilar simplicity for simple matches\n\n\nHandling Complex Structures\nRequires manual decomposition\nCan match directly on structures\n\n\nDeconstruction\nRequires explicit unpacking\nAutomatically deconstructs data structures\n\n\nType Matching\nNeeds isinstance() checks\nCan match types directly\n\n\nReadability\nBecomes verbose with complex logic\nMore concise for complex scenarios\n\n\nFlexibility\nCan use if-elif-else chains for conditions\nCan handle advanced pattern matching with custom conditions\n\n\n\nExample:\nfiltered_sequences = []\ndna_sequences = [\n    \"ATCGTAGCTAGCTAGCTAGCTA\",\n    \"ATCG\",\n    \"ATGCGTAGCTAGCTAGCTAGCTAGCTAG\",\n    12345,\n    \"ATCGTAGCTAGCTAGCTAGCTAGC\"\n]\n\nfor sequence in dna_sequences:\n    match sequence:\n        case str():\n          print(f' reported DNA is {sequence}')\n          filtered_sequences.append(sequence)\n        case int():\n          print(f'{sequence} is not DNA')\n        case _:\n          print(f'{sequence} is not DNA')\n\nprint(filtered_sequences)\n\nOutput:\n reported DNA is ATCGTAGCTAGCTAGCTAGCTA\n reported DNA is ATCG\n reported DNA is ATGCGTAGCTAGCTAGCTAGCTAGCTAG\n12345 is not DNA\n reported DNA is ATCGTAGCTAGCTAGCTAGCTAGC\n['ATCGTAGCTAGCTAGCTAGCTA', 'ATCG', 'ATGCGTAGCTAGCTAGCTAGCTAGCTAG', 'ATCGTAGCTAGCTAGCTAGCTAGC']\n\n\n\n\n\n\n\nExercise 6 - Short Description\n\n\n\n\n\n\nLevel: \nHow would you do the above if you had to use if statements?\n\n\n\n\n\n\n\n\n\n\nExercise 7 - Short Description\n\n\n\n\n\n\nLevel: \nUse the animal_speeds dictionary in the previous exercise and write a match statement which would give the desired output\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nanimal_speeds = {\n    \"Cheetah\": 120,\n    \"Tortoise\": 0.3,\n    \"Falcon\": \"fast\",  # Intentional error: speed should be a number\n    \"Horse\": 88,\n    \"Elephant\": 40,\n}\n\nfor index, (animal, speed) in enumerate(animal_speeds.items(), start=1):\n    match (animal, speed):\n        case (str(), int()|float()):\n            if s &gt; 50:\n                print(f\"{index}. {animal} is fast with a maximum speed of {speed} km/h!\")\n            else:\n                print(f\"{index}. {animal} is slow with a maximum speed of {speed} km/h.\")\n        case (animal,int()|float()):\n            print(f\"{index}. Invalid animal name: {animal}\")\n        case (str(),speed):\n            print(f\"{index}. {animal} has an invalid speed value: {speed}\")\n        case _:\n            print(\"Unknown error\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 8 - Short Description\n\n\n\n\n\n\nLevel: \nDiscussion: Can match statements replace try except?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nNO! - match statements can reduce the errors and deal with edge casees, but errors can arise within the cases that cannot be handled.\n\nEdge cases can be different to errors - the code runs without throwing errors but the output does not behave as expected\nYou should always inspect data first and check things make sense.\n\n\n\n\n\n\n\n\n\nAutomatic Unpacking with match statements:\ndna_data = {\n    \"sequence\": \"AGCTAGCCTAAGT\",\n    \"length\": 12,\n    \"type\": \"coding\"\n}\n\n# match statement to unpack DNA information\nmatch dna_data:\n    case {\"sequence\": sequence, \"length\": length, \"type\": type}:\n        print(f\"The DNA sequence is {sequence}, it has a length of {length} bases, and it is of type '{type}'.\")\n    case {\"sequence\": sequence, \"length\": length}:\n        print(f\"The DNA sequence is {sequence} and has a length of {length} bases, but type information is missing.\")\n    case {\"sequence\": sequence}:\n        print(f\"The DNA sequence is {sequence}, but length and type information are missing.\")\n    case _:\n        print(\"Unknown DNA data.\")\nOutput:\nThe DNA sequence is AGCTAGCCTAAGT, it has a length of 12 bases, and it is of type 'coding'.\nThis can be incredibly useful when writing functions which we will get on to shortly",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Conditionals and Loops in Python</span>"
    ]
  },
  {
    "objectID": "materials/07-conditionals-and-loops-in-python.html#list-comprehensions",
    "href": "materials/07-conditionals-and-loops-in-python.html#list-comprehensions",
    "title": "9  Conditionals and Loops in Python",
    "section": "9.7 List Comprehensions",
    "text": "9.7 List Comprehensions\nList comprehensions in python enable you to write shorter and sometimes faster code than standard loops. The syntax is:\n[expression for item in iterable if condition]\nSimilar tools occur for dictionaries (Dictionary comprehension)\n\n\n\n\n\n\nExercise 9 - Use list Comprehensions\n\n\n\n\n\n\nLevel: \nprint the animals list in upper case using list comprehensions\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nAnswer:\nanimals = [\"dog\", \"cat\", \"rabbit\", \"elephant\"]\nprint([animal.upper() for animal in animals])\noutput:\n['DOG', 'CAT', 'RABBIT', 'ELEPHANT']",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Conditionals and Loops in Python</span>"
    ]
  },
  {
    "objectID": "materials/07-conditionals-and-loops-in-python.html#while-loops-in-python",
    "href": "materials/07-conditionals-and-loops-in-python.html#while-loops-in-python",
    "title": "9  Conditionals and Loops in Python",
    "section": "9.8 while Loops in Python",
    "text": "9.8 while Loops in Python\nA while loop in Python is a control flow statement that allows code to be executed repeatedly based on a boolean condition. The loop continues to execute as long as the condition remains True. Here’s a breakdown of how while loops work:\nKey Components\n\nCondition: The loop starts with a condition that is evaluated before each iteration. If the condition is True, the code block within the loop is executed.\nCode Block: The statements inside the loop are indented, and these will run repeatedly as long as the condition remains True.\nIncrement/Decrement: It’s crucial to modify the variable used in the condition within the loop; otherwise, you may create an infinite loop.\nExit: Once the condition evaluates to False, the loop stops, and the program continues with the next line of code following the loop.\n\nSyntax\nwhile condition:\n    # Code block to execute\n    # Update condition variable\nExample\nHere’s a simple example to illustrate how a while loop works:\ncount = 0\n\nwhile count &lt; 5:\n    print(\"Count is:\", count)\n    count += 1  # Increment count\nExplanation of the Example\n\nInitialization: The variable count is initialized to 0.\nCondition: The while loop checks if count is less than 5.\nCode Execution: If the condition is True, it prints the current value of count.\nIncrement: The line count += 1 increments the value of count by 1 after each iteration.\nTermination: Once count reaches 5, the condition becomes False, and the loop exits.\n\nThis can be incredibly useful in simulations. Or when interacting in the environment. Here the number of iterations is not known beforehand and depend on a certain condition being met. They provide a way to repeat actions and process data dynamically within a program.\nHowever\n\nInfinite Loops: Ensure the condition will eventually evaluate to False to avoid infinite loops.\nBreak Statement: You can use the break statement to exit a loop prematurely if needed.\nContinue Statement: The continue statement can skip the current iteration and proceed to the next one based on a condition.\n\nAn example is:\nimport random\n\npopulation = 1000\ninfected = 1\ndays = 0\ninfection_rate = 1.5\nmax_days = 30\n\nwhile infected &lt; population:\n    days += 1\n\n    if random.random() &gt; 0.9:\n        print(f\"Day {days}: Lockdown in effect, no new infections today.\")\n        continue\n    \n    new_infections = int(infected * infection_rate)\n\n    if new_infections + infected &gt; population:\n        new_infections = population - infected\n    \n    infected += new_infections\n\n    print(f\"Day {days}: {infected} infected.\")\n\n    if infected &gt;= population:\n        print(f\"Day {days}: The entire population is infected.\")\n        break\n\n    if random.random() &gt; 0.8:\n        print(f\"Day {days}: Health measures implemented, slowing infection.\")\n        infection_rate -= 0.3\n    \n    if infection_rate &lt;= 0.1:\n        print(f\"Day {days}: The infection has nearly stopped spreading.\")\n        break\n    \n    if days &gt;= max_days:\n        print(\"The simulation has reached its time limit.\")\n        break\n\n\n\n\n\n\n\nExercise 10 - Code Legibility\n\n\n\n\n\n\nLevel: \nDiscussion: What does the above code do? Is it legibly written? What can be done to improve this?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n\n# Commenting the code appropriately is important!\nimport random\n\n# Parameters of the simulation\npopulation = 1000       # Total population\ninfected = 1            # Initially 1 person is infected\ndays = 0                # Start at day 0\ninfection_rate = 1.5    # Rate of infection: how many people one infected person can infect per day\nmax_days = 30           # Maximum number of days to simulate\n\nwhile infected &lt; population:\n    days += 1\n\n    # Simulate random events like lockdown or vaccines\n    if random.random() &gt; 0.9:  # 10% chance of stopping the spread for the day\n        print(f\"Day {days}: Lockdown in effect, no new infections today.\")\n        continue  # Skip the infection calculation for this day and move to the next\n\n    # Simulate daily infections\n    new_infections = int(infected * infection_rate)\n\n    # If new infections exceed the remaining healthy population, adjust them\n    if new_infections + infected &gt; population:\n        new_infections = population - infected\n\n    infected += new_infections\n\n    # Display day-by-day status\n    print(f\"Day {days}: {infected} infected.\")\n\n    # Continue if there are still people to infect\n    if infected &gt;= population:\n        print(f\"Day {days}: The entire population is infected.\")\n        break\n\n    # Random chance to reduce the infection rate due to interventions\n    if random.random() &gt; 0.8:  # 20% chance to reduce infection rate\n        print(f\"Day {days}: Health measures implemented, slowing infection.\")\n        infection_rate -= 0.3  # Decrease the infection rate\n\n    # If the infection rate gets too low, break out of the loop (end of epidemic)\n    if infection_rate &lt;= 0.1:\n        print(f\"Day {days}: The infection has nearly stopped spreading.\")\n        break\n\n    # Stop the simulation after a max number of days to avoid infinite loops\n    if days &gt;= max_days:\n        print(\"The simulation has reached its time limit.\")\n        break",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Conditionals and Loops in Python</span>"
    ]
  },
  {
    "objectID": "materials/07-conditionals-and-loops-in-python.html#summary",
    "href": "materials/07-conditionals-and-loops-in-python.html#summary",
    "title": "9  Conditionals and Loops in Python",
    "section": "9.9 Summary",
    "text": "9.9 Summary\nPython has many ways to work with conditions and loops. It is key for these statements to be written concisely, while catching edge cases and dealing with errors.\n\n\n\n\n\n\nKey Points\n\n\n\nBy this point you should be comfortable with:\n\nif, elif, else statements\nmatch , case statements\nfor loops with range(), len(), and enumerate()\nWorking with different composite data types\ntry and except for error handling\nwhile loops",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Conditionals and Loops in Python</span>"
    ]
  },
  {
    "objectID": "materials/08-defining-functions-and-classes.html",
    "href": "materials/08-defining-functions-and-classes.html",
    "title": "10  Defining Functions and Classes",
    "section": "",
    "text": "10.1 Defining Functions in Python\nFunctions in Python are blocks of reusable code designed to perform a specific task. They help organise code, promote reusability, and make programs more readable.\nSyntax of a Function\nThe basic syntax for defining a function in Python is:\nExample 1: Function with No Parameters\nExample 2: Function with Parameters\nIt uses that parameter to personalize the greeting. Calling the function:\nOutput:\nExample 3: Function with Multiple Parameters and a Return Value\nThis function takes two parameters, a and b. It returns the sum of the two numbers. Calling the function:\nOutput:\nExample 4: Function with Default Parameters\nYou can set default values for parameters so that a function can be called with fewer arguments than defined.\nCalling the function with and without the parameter:\noutput\nExample 5: Function with Multiple Outputs\nA function can return more than one value using tuples or other data structures.\nCalling the function and unpacking values:\nOutput:\nFunctions Summary\nFunctions in Python are defined using the def keyword. Inputs (parameters) can be passed into functions, and outputs can be returned using the return statement. Functions can have default parameters, accept multiple arguments, and return multiple values.",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Defining Functions and Classes</span>"
    ]
  },
  {
    "objectID": "materials/08-defining-functions-and-classes.html#defining-functions-in-python",
    "href": "materials/08-defining-functions-and-classes.html#defining-functions-in-python",
    "title": "10  Defining Functions and Classes",
    "section": "",
    "text": "def function_name(parameters):\n    \"\"\"Docstring explaining the function\"\"\"\n    # Function body\n    value = 1\n    return value\n\ndef: This keyword is used to define a function.\nfunction_name: The name you choose for the function.\nparameters: Optional. Values that the function accepts as inputs. If there are multiple, they are separated by commas.\nreturn: Optional. The function can return a value using the return statement.\n\n\ndef welcome():\n    print(\"Hello, World!\")\n\ndef welcome_person(name):\n    print(f\"Hello, {name}!\")\nThis function accepts a single parameter, name.\n\nwelcome_person(\"Kavi\")\n\nHello, Kavi!\n\ndef add_numbers(a, b):\n    return a + b\n\nresult = add_numbers(5, 10)\nprint(result)\n\n15\n\n\ndef welcome_person(name=\"Guest\"):\n    print(f\"Hello {name}, nice to meet you!\")\n\n\n\nwelcome_person(\"Tom\")  # Uses the provided argument\nwelcome_person()         # Uses the default value\n\n\nHello Tom, nice to meet you!\nHello Guest, nice to meet you!\n\n\ndef calculate(a, b):\n    sum_val = a + b\n    product_val = a * b\n    return sum_val, product_val\n\nsum_1, product_1 = calculate(3, 4)\nprint(sum_1, product_1)\n\n7 12",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Defining Functions and Classes</span>"
    ]
  },
  {
    "objectID": "materials/08-defining-functions-and-classes.html#classes-in-python",
    "href": "materials/08-defining-functions-and-classes.html#classes-in-python",
    "title": "10  Defining Functions and Classes",
    "section": "10.2 Classes in Python",
    "text": "10.2 Classes in Python\nIn Python, a class is a standard way of creating objects (instances). It allows you to bundle data (attributes) and functions (methods) into a single unit. Classes define the structure and behaviour of objects in an object-oriented programming style.\n\n\n\n\n\n\nExercise 1 - Discussion\n\n\n\n\n\n\nLevel: \nWhere have we seen this already in the course material?\n\n\n\n\nBasic Syntax of a Python Class:\nclass MyClass:\n    # Constructor to initialize the object\n    def __init__(self, attribute1, attribute2):\n        self.attribute1 = attribute1  # Instance variable\n        self.attribute2 = attribute2  # Instance variable\n\n    # Method (function) within the class\n    def my_method(self):\n        print(f\"Attribute 1: {self.attribute1}\")\n        print(f\"Attribute 2: {self.attribute2}\")\nKey Concepts:\n\n__init__() Method: This is the constructor method that gets called when a new object of the class is created. It initializes the object’s attributes.\nAttributes: Variables that belong to an object, defined by self.attribute_name.\nMethods: Functions defined inside a class that operate on the object’s attributes.\nInstance: An individual object created from the class.\n\nExample for biologists:\nclass BioComponent:\n    def __init__(self, name, id, sequence, function):\n        self.name = name\n        self.id = id\n        self.sequence = sequence\n        self.length = len(sequence)\n        self.function = function\n\n    # Method to pad the sequence with user input on either side\n    def pad(self, left_pad, right_pad):\n        self.sequence = left_pad + self.sequence + right_pad\n        self.length = len(self.sequence)  # Update the length\n        print(f\"Padded sequence: {self.sequence}, New length: {self.length}\")\n\n    # Method to perform a point mutation (replace a character at a specified position)\n    def point_mutate(self, position, new_char):\n        if position &lt; 0 or position &gt;= self.length:\n            print(\"Position out of bounds.\")\n            return\n        self.sequence = self.sequence[:position] + new_char + self.sequence[position + 1:]\n        print(f\"Mutated sequence: {self.sequence}\")\n\n# Inherited class Gene that restricts mutations to A, T, C, G only\nclass Gene(BioComponent):\n    def point_mutate(self, position, new_char):\n        if new_char not in \"ATCG\":\n            print(\"Error: Invalid base. Must be one of A, T, C, G.\")\n            return\n        super().point_mutate(position, new_char)  # Call parent class method\n\n# Example Usage\n# Create an instance of BioComponent\ncomponent = BioComponent(name=\"ProteinX\", id=101, sequence=\"MKTFFY\", function=\"Signalling\")\nprint(f\"Initial sequence: {component.sequence}, Length: {component.length}\")\n\n# Use the pad method\ncomponent.pad(\"AAA\", \"BBB\")\n\n# Perform a point mutation at position 2 (index starts at 0)\ncomponent.point_mutate(2, \"Q\")\n\n# Create an instance of Gene (inherits from BioComponent)\ngene = Gene(name=\"GeneX\", id=202, sequence=\"ATGCGT\", function=\"Coding for protein\")\nprint(f\"Initial gene sequence: {gene.sequence}, Length: {gene.length}\")\n\n# Perform a valid point mutation with a valid base (A, T, C, G)\ngene.point_mutate(3, \"A\")\n\n# Attempt an invalid point mutation with an invalid base (not A, T, C, G)\ngene.point_mutate(2, \"X\")\n\nExplanation:\nBioComponent Class:\n\nThe __init__ method initializes the name, id, sequence, length (calculated automatically), and function of the component.\nThe pad method adds user-inputted strings (left_pad, right_pad) on either side of the sequence and updates the sequence’s length accordingly.\nThe point_mutate method allows any character to replace one at a specific position in the sequence, updating the sequence accordingly.\n\nGene Class:\n\nInherits from BioComponent and overrides the point_mutate method to ensure that only valid DNA bases (A, T, C, G) can be used for mutation.\nCalls the parent class’s point_mutate method if the mutation is valid.\n\nExample Usage:\n\nA BioComponent (e.g., a protein) can be padded and mutated freely with any character.\nA Gene restricts mutations to valid DNA bases and throws an error if any invalid base is provided.\nThe super().point_mutate(position, new_char) call in the Gene class refers to invoking the point_mutate method from its parent class (BioComponent). The super() function is used to give access to methods of the parent class from within a child class.\nWhen the Gene class overrides the point_mutate method, it restricts the mutations to DNA bases (A, T, C, G). After checking that the new character (new_char) is valid, the super().point_mutate(position, new_char) call allows the Gene class to reuse the logic of point_mutate from BioComponent to actually mutate the sequence.\n\nHow super() Works in This Case:\n\nsuper() looks up the parent class of Gene (which is BioComponent).\nsuper().point_mutate(position, new_char) calls the point_mutate method of BioComponent with the position and new_char arguments.\nThis lets Gene use the existing logic of point_mutate defined in BioComponent for sequence mutation, without having to reimplement it.\n\n\n\n\n\n\n\nExercise 2 - Add class function and inherited class\n\n\n\n\n\n\nLevel: \nAdd your own function to the biocomponent class. Add protein as a class inherited from the biocomponent class and decide if you want to overide the functions\n\n\n\n\n\n\n\n\n\n\nExercise 3 - Discussion\n\n\n\n\n\n\nLevel: \nWhat have I not added in many of these examples (including the syntax note), that I should have?\n\n\n\n\n\n\nHint\n\n\n\n\n\n\ntry run the help() function on MyClass and function_name()\n\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nDocstring comments. While this may not be super important here, when you start using your own written functions as modules they are important!\n\nclass BioComponent:\n    \"\"\"\n    A class to represent a biological component (like a protein or gene).\n    \n    Attributes:\n    -----------\n    name : str\n        Name of the component.\n    id : str\n        Unique identifier for the component.\n    sequence : str\n        The biological sequence (e.g., amino acids or nucleotides).\n    length : int\n        Length of the sequence (calculated automatically).\n    function : str\n        Description of the component's biological function.\n    \"\"\"\n    \n    def __init__(self, name, id, sequence, function):\n        \"\"\"\n        Initialize a BioComponent with name, id, sequence, and function.\n        \n        Parameters:\n        -----------\n        name : str\n            The name of the component.\n        id : str\n            The unique identifier for the component.\n        sequence : str\n            The biological sequence of the component.\n        function : str\n            The biological function of the component.\n        \"\"\"\n        self.name = name\n        self.id = id\n        self.sequence = sequence\n        self.length = len(sequence)\n        self.function = function\n    \n    def pad(self, left_pad, right_pad):\n        \"\"\"\n        Pads the sequence with the given left and right strings.\n        \n        Parameters:\n        -----------\n        left_pad : str\n            The string to add to the left of the sequence.\n        right_pad : str\n            The string to add to the right of the sequence.\n        \"\"\"\n        self.sequence = left_pad + self.sequence + right_pad\n        self.length = len(self.sequence)  # Update the length\n        \n    def point_mutate(self, position, new_char):\n        \"\"\"\n        Mutates the sequence by replacing a character at the specified position.\n        \n        Parameters:\n        -----------\n        position : int\n            The index at which to replace the character.\n        new_char : str\n            The new character to insert into the sequence.\n        \"\"\"\n        if 0 &lt;= position &lt; self.length:\n            self.sequence = self.sequence[:position] + new_char + self.sequence[position + 1:]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 4 - Define Your own Data Type\n\n\n\n\n\n\nI mentioned in python that it is easy to define your own data types. Now you have all the tools to do it!\nDefine your own composite data type with unique attributes and write some functions for it!\nWhat is it useful for?",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Defining Functions and Classes</span>"
    ]
  },
  {
    "objectID": "materials/08-defining-functions-and-classes.html#local-and-global-variables-instance-and-class-attributes",
    "href": "materials/08-defining-functions-and-classes.html#local-and-global-variables-instance-and-class-attributes",
    "title": "10  Defining Functions and Classes",
    "section": "10.3 Local and Global Variables, instance and class attributes",
    "text": "10.3 Local and Global Variables, instance and class attributes\nIn Python, variables can be classified into two main categories based on their scope: local and global variables.\nLocal Variables\n\nA local variable is a variable that is defined inside a function and is only accessible within that function. Once the function exits, the local variable is destroyed, and its value cannot be accessed from outside the function.\n\nExample\ndef my_name():\n    name = \"Kavi\"  # Local variable\n    print(\"Inside the function my name is:\", x)\n\nmy_name()\nprint(name)  # This would raise an error because x is not accessible outside the function.\nGlobal Variables\n\nA global variable is a variable that is defined outside of any function and is accessible throughout the program, including within functions (unless specifically overridden within a function). Global variables maintain their values until the program terminates.\n\nEaxample:\n\nnumber = 1  # Global variable\n\ndef my_number():\n    print(\"Inside the function the number is:\", number)\n\nmy_number()  # Can access the global variable\nprint(\"Outside the function:\", number)  # Global variable accessible here as well\n\nModifying Global Variables Inside a Function\n\nIf you want to modify a global variable within a function, you need to explicitly declare it as global using the global keyword. Without the global keyword, Python would treat the variable as a new local variable inside the function, and the global variable would remain unchanged.\n\nExample:\nage = 30  # Global variable\n\ndef my_age():\n    global age\n    age += 1  # Modifying the global variable\n    print(\"Inside the function:\", age)\n\nmy_age()\nprint(\"Outside the function:\", age)  # Global variable now changed\n\n__main__ in Python\n\nIn Python, __main__ refers to the environment where the top-level code is being executed. When a Python script is run directly, Python assigns the special name \"__main__\" to the __name__ variable in that script.\n\nif __name__ == \"__main__\":\n\nThis construct is used to check if a script is being run directly or being imported as a module in another script. The code under this condition will only be executed if the script is run directly.\n\nExample:\n# script.py\ndef welcome():\n    print(\"Hello, world!\")\n\nif __name__ == \"__main__\":\n    welcome()\n\nPurpose of __main__:\n\nTesting and Debugging: It allows you to write test code in the same file without it running when the file is imported elsewhere.\nModular Code: It helps keep code modular, where functions and classes are defined for reuse, but certain behaviours (like running a function) are executed only when the file is executed directly.\n\n\nLocal and Global Variables in Classes\nWhen dealing with classes in Python, the concept of local and global variables applies similarly, but there are additional layers related to instance and class attributes.\nInstance and Class Attributes In addition to local and global variables, classes introduce two other types of variables: instance attributes and class attributes.\n\nInstance Attributes: These are specific to an instance (object) of a class. Each object has its own separate copy of these attributes.\nClass Attributes: These are shared among all instances of a class and are declared outside the __init__() method.\n\nExample\nclass MyClass:\n    class_variable = 5  # Class attribute, shared by all instances\n\n    def __init__(self, value):\n        self.value = value  # Instance attribute\n\nobj1 = MyClass(10)\nobj2 = MyClass(20)\n\nprint(obj1.class_variable)  # 5\nprint(obj2.class_variable)  # 5\nprint(obj1.value)           # 10\nprint(obj2.value)           # 20\n\nSummary of variables:\n\nLocal variables are declared inside a function and only exist within that function.\nGlobal variables are declared outside of functions and can be accessed anywhere in the script unless shadowed by a local variable.\nThe __name__ == \"__main__\" construct is used to determine if a script is being run directly or imported, allowing control over code execution in different contexts.\nInstance attributes are tied to specific objects of a class.\nClass attributes are shared among all instances of a class.\nGenerally speaking, I think it is always a good idea to clearly add inputs and outputs to a function in any complex function. This includes global variables, as you may want to use those functions in other scripts that do not have the same global variables.",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Defining Functions and Classes</span>"
    ]
  },
  {
    "objectID": "materials/08-defining-functions-and-classes.html#summary",
    "href": "materials/08-defining-functions-and-classes.html#summary",
    "title": "10  Defining Functions and Classes",
    "section": "10.4 Summary",
    "text": "10.4 Summary\nNow you have had a look at building functions and classes. They are key parts of programming in python. Imagine living in a world without being able to define and call functions in python. Just think of the amount of code you would have to write and sift through!\n\n\n\n\n\n\nKey Points\n\n\n\n\nFunctions: Reusable blocks of code that perform a specific task. They help you concisely repeat different kinds of tasks.\nClasses: Blueprints for creating objects (instances) that bundle data (attributes) and behaviour (methods). They are part of the Object-Oriented Programming paradigm. Both are useful for improving code structure, making it more modular, maintainable, and easier to debug.\nVariables: Local and global variables, and instance and class attributes are important to manage. Being explicit with input and output variables in functions is often better.",
    "crumbs": [
      "Session-1",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Defining Functions and Classes</span>"
    ]
  },
  {
    "objectID": "materials/09-session-1-recap-and-exercises-wa.html",
    "href": "materials/09-session-1-recap-and-exercises-wa.html",
    "title": "11  Recap Exercise",
    "section": "",
    "text": "11.1 Overview\nToday we have a range of exciting topics to cover, however the style of teaching will be a little different from the first day. There will be fewer notes, and you will use the documentation pages and other resources to help you. There will be much more self-learning involved. This is a little closer to how things will be when you are undertaking projects on your own.\nBefore we go on to the new parts, have a try at this exercise to test how familiar you are with the content from the last session:\nAnswers will be uploaded after the session",
    "crumbs": [
      "Session-2",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Recap Exercise</span>"
    ]
  },
  {
    "objectID": "materials/09-session-1-recap-and-exercises-wa.html#overview",
    "href": "materials/09-session-1-recap-and-exercises-wa.html#overview",
    "title": "11  Recap Exercise",
    "section": "",
    "text": "Exercise 1 - Phenotypes and Genes\n\n\n\n\n\n\nLevel: \nWrite a global variable which has the DNA to RNA transitions as a dictionary, and a global variable that has the DNA to amino acid transitions as a dictionary.\n1. Initiaise a class gene which\nhas the class variables:\n\ntpye = protein_coding\n\nHas the attributes:\n\nname\nid\nlength\ncoding sequence\nrna sequence\nprotein sequence\n\nAnd has functions:\n\nadd_length: to add length based on the coding sequence (deal with invalid characters)\nadd_RNA to turn it into an RNA sequence (deal with invalid characters)\nadd_protein_seq: to turn it into a protein sequence if it has a dna sequence\nmodify_sequence: to alter a base of the DNA sequence at ‘x’ position and update the length, RNA and protein sequence\nprint the attributes\n\n2. Write a list of 10 made-up gene names\n3. Using a ‘for loop’/‘list comprehension’, and a random number generator, generate a dictionary of the 10 DNA sequences of 100 bases associated with the gene_names. note:\nimport random\nrandom.choices(options_list) #will make random choices on an options list\nrandom.choices(options_list, k=100) # can be used to generate 100 outputs in one go\n4. Use the dictionary to initialise 10 gene objects.\n5. Initialise a class phenotype which is made up of:\nattributes:\n\nname\ndescription (a string description”)\ncontributing genes (a list of gene objects)\n\nfunctions:\n\nadd multiple genes to the list\nremove genes from list\nappend extra lines to the description\nreplace the description.\nprint the attributes , and the attributes of the genes held.\n\nUse ‘try’, ‘except’, and ‘match’ to deal with errors.\n6. Use a ‘for loop’ to initialise three phenotypes.\n7. What is the size of the gene objects and phenotype objects using sys.getsizeof()?\n8. What does this tell you about the sys.getsizeof() function?\n9. Modify the sequence of one of the geneobjects - does the phenotype object change as seen when you print all the attributes.\n10. Make a deep copy of a gene object and show that it is a deep copy.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Global variable for DNA to RNA transitions\nDNA_TO_RNA_TRANSITIONS = {\n    'A': 'U',\n    'T': 'A',\n    'C': 'G',\n    'G': 'C'\n}\n\n# Global variable for DNA to Amino Acid transitions\nDNA_TO_AMINO_ACID_TRANSITIONS = {\n    # DNA codon to single-letter amino acid code dictionary (sorted)\n    \"TTT\":\"F\",\n    \"TTC\":\"F\",\n    \"TTA\":\"L\",\n    \"TTG\":\"L\",\n    \"TCT\":\"S\",\n    \"TCC\":\"S\",\n    \"TCA\":\"S\",\n    \"TCG\":\"S\",\n    \"TAT\":\"Y\",\n    \"TAC\":\"Y\",\n    \"TAA\":\"X\",\n    \"TAG\":\"X\",\n    \"TGT\":\"C\",\n    \"TGC\":\"C\",\n    \"TGA\":\"X\",\n    \"TGG\":\"W\",\n    \"CTT\":\"L\",\n    \"CTC\":\"L\",\n    \"CTA\":\"L\",\n    \"CTG\":\"L\",\n    \"CCT\":\"P\",\n    \"CCC\":\"P\",\n    \"CCA\":\"P\",\n    \"CCG\":\"P\",\n    \"CAT\":\"H\",\n    \"CAC\":\"H\",\n    \"CAA\":\"Q\",\n    \"CAG\":\"Q\",\n    \"CGT\":\"R\",\n    \"CGC\":\"R\",\n    \"CGA\":\"R\",\n    \"CGG\":\"R\",\n    \"ATT\":\"I\",\n    \"ATC\":\"I\",\n    \"ATA\":\"I\",\n    \"ATG\":\"M\",\n    \"ACT\":\"T\",\n    \"ACC\":\"T\",\n    \"ACA\":\"T\",\n    \"ACG\":\"T\",\n    \"AAT\":\"N\",\n    \"AAC\":\"N\",\n    \"AAA\":\"K\",\n    \"AAG\":\"K\",\n    \"AGT\":\"S\",\n    \"AGC\":\"S\",\n    \"AGA\":\"R\",\n    \"AGG\":\"R\",\n    \"GTT\":\"V\",\n    \"GTC\":\"V\",\n    \"GTA\":\"V\",\n    \"GTG\":\"V\",\n    \"GCT\":\"A\",\n    \"GCC\":\"A\",\n    \"GCA\":\"A\",\n    \"GCG\":\"A\",\n    \"GAT\":\"D\",\n    \"GAC\":\"D\",\n    \"GAA\":\"E\",\n    \"GAG\":\"E\",\n    \"GGT\":\"G\",\n    \"GGC\":\"G\",\n    \"GGA\":\"G\",\n    \"GGG\":\"G\",\n}\n\nclass Gene:\n    # Class variable\n    type = \"protein_coding\"\n    \n    def __init__(self, name, gene_id, coding_sequence):\n        self.name = name\n        self.gene_id = gene_id\n        self.length = None  # Initialize length to None\n        self.coding_sequence = coding_sequence.upper()  # Ensure sequence is uppercase\n        self.rna_sequence = \"\"\n        self.protein_sequence = \"\"\n\n    def add_length(self):\n        \"\"\"\n        Calculate the length of the coding sequence, ignoring invalid characters.\n        \"\"\"\n        valid_bases = {'A', 'T', 'C', 'G'}\n        self.length = sum(1 for base in self.coding_sequence if base in valid_bases)\n        print(f\"Length updated: {self.length}\")\n\n    def add_RNA(self):\n        \"\"\"\n        Convert the DNA sequence to an RNA sequence.\n        \"\"\"\n        try:\n            rna_sequence = []\n            for base in self.coding_sequence:\n                if base in DNA_TO_RNA_TRANSITIONS:\n                    rna_sequence.append(DNA_TO_RNA_TRANSITIONS[base])\n                else:\n                    raise ValueError(f\"Invalid base '{base}' in DNA sequence.\")\n            self.rna_sequence = ''.join(rna_sequence)\n            print(f\"RNA sequence added: {self.rna_sequence}\")\n        except ValueError as e:\n            print(f\"Error: {e}\")\n\n    def add_protein_seq(self):\n        \"\"\"\n        Convert DNA sequence to a protein sequence if exists.\n        \"\"\"\n        if self.coding_sequence:\n            protein_sequence = []\n            for i in range(0, len(self.coding_sequence) - 2, 3):  # Iterate in steps of 3\n                codon = self.coding_sequence[i:i + 3]\n                if codon in DNA_TO_AMINO_ACID_TRANSITIONS:\n                    amino_acid = DNA_TO_AMINO_ACID_TRANSITIONS[codon]\n                    if amino_acid == 'STOP':\n                        break\n                    protein_sequence.append(amino_acid)\n                else:\n                    print(f\"Warning: Codon '{codon}' not recognized.\")\n            self.protein_sequence = ''.join(protein_sequence)\n            print(f\"Protein sequence added: {self.protein_sequence}\")\n        else:\n            print(\"DNA sequence not available. Cannot generate protein sequence.\")\n\n    def modify_sequence(self, position, new_base):\n        \"\"\"\n        Modify a base of the DNA sequence at position and update length, RNA, and protein sequences.\n        \"\"\"\n        try:\n            if position &lt; 0 or position &gt;= len(self.coding_sequence):\n                raise IndexError(\"Position out of range.\")\n            valid_bases = {'A', 'T', 'C', 'G'}\n            if new_base not in valid_bases:\n                raise ValueError(\"Invalid base. Must be A, T, C, or G.\")\n            \n            # Modify the base\n            self.coding_sequence = self.coding_sequence[:position] + new_base + self.coding_sequence[position + 1:]\n            print(f\"Modified DNA sequence: {self.coding_sequence}\")\n\n            # Update length, RNA, and protein sequences\n            self.add_length()\n            self.add_RNA()\n            self.add_protein_seq()\n        except (IndexError, ValueError) as e:\n            print(f\"Error: {e}\")\n\n    def print_attributes(self):\n        \"\"\"\n        Print the attributes of the gene.\n        \"\"\"\n        print(f\"Gene Name: {self.name}\")\n        print(f\"Gene ID: {self.id}\")\n        print(f\"Length: {self.length}\")\n        print(f\"Coding Sequence: {self.coding_sequence}\")\n        print(f\"RNA Sequence: {self.rna_sequence}\")\n        print(f\"Protein Sequence: {self.protein_sequence}\")\n\n# Example usage:\n#gene1 = Gene(name=\"Gene1\", id=\"G001\", coding_sequence=\"ATGCTGAAATAG\")\n#gene1.add_length()  # Calculate and set the length\n#gene1.add_RNA()     # Convert to RNA\n#gene1.add_protein_seq()  # Convert to protein sequence\n#gene1.modify_sequence(3, 'A')  # Modify a base\n#gene1.print_attributes()  # Print the attributes of the gene\n\nnow generate the dictionary of gene_name gene_sequence pairs\n\nimport random\n\n# Step 1: List of 10 made-up gene names\ngene_names = [\n    \"GeneA1\",\n    \"GeneB2\",\n    \"GeneC3\",\n    \"GeneD4\",\n    \"GeneE5\",\n    \"GeneF6\",\n    \"GeneG7\",\n    \"GeneH8\",\n    \"GeneI9\",\n    \"GeneJ0\"\n]\n\n# Step 2: Generate a dictionary of 10 DNA sequences of 100 bases each\nbases = ['A', 'T', 'C', 'G']  # Possible DNA bases\n#using dictionary comprehension, string methods \ngene_sequences = {gene: ''.join(random.choices(bases, k=100)) for gene in gene_names}\n\n# Output the dictionary of gene sequences\nprint(gene_sequences)\n\nOutput:\n\n{'GeneA1': 'GTTGAGATCCTCTAACTATGGCTGTACGGACTTCAATTAGTCGCGACTTCGGCAAGCTCCCCCATCTTTACCCAGACATCTATCCAATTGCATCACATCC', 'GeneB2': 'GTTCGGACCCGTCTGTGCCGCTGAACGTCTACTGCCCGATAAGTCTTAGCCTCAAATATATACAGAAGAAAACATCATACTGCTGTTCGTGAAGTTCTGG', 'GeneC3': 'TTCTACACTTATACTAGAACATGATTTCATTTCACCCAATAGATATACCGGGTGACTCATTTGGTAGGGTGGGATTGTAGAACGGTTACAACGGGTATGA', 'GeneD4': 'GACGGTGGCACATGACTCTGGGCTGTGCCATATAAAGGGGATAGCTCGCTGCCTTTGTTGCCGATTTGTCGTGGCGCTGCAGCTTGTCGGTGTTGTAATC', 'GeneE5': 'TAGTTGCAAGCGAGCGGGGTGGGTGCAGCTGTGTTAGCGATTCCGTTTCTGCCCACAACACTCCATGTCGAGCCATTATAAGATGAACGAGAAAAGCGGA', 'GeneF6': 'TCCCATTGTTGCACTCCGGACCTCAGATGCGGGGACCCCTAAAACGCTGTCCTTGTCACCCGTTTACAATGATGCTAACGTTGCGCAAATCTTTCACCTG', 'GeneG7': 'AGGTGAACTAATCAGTTACCTTTCTTCTAACTGTTACCCCAAGTAGCAGACAAACAGTCGTGGAATCCGCAGCGATCCGTTGTCCGTCCATCTTACCCTG', 'GeneH8': 'ACGGATTCAACAGGGCACACGTAACTACCTGATCGTGGTTAGGATCTTATTGGACGGGGTAATCGAGATGCTCTTATGTAGGCTCGAGTGTTGTCCATGG', 'GeneI9': 'TTTGTCACGCAGCGGCAACTCCACCGCCGGCTCTAGGCATGCCACGTTTCTGAACCATCTGACCACAGCTCGGACTGGATAAGGTCAGGTACGGATTCCC', 'GeneJ0': 'ATGTTCGGACACGGTGGCAATTACAACTCAAAGCCTCCAGACTGCTAGCTTGACAATTGGATCTTCCAGGCCACTAGACATGTACGTGATCCGCTTCAAC'}\n\nNow generate the gene_objects:\ngene_objects = []\nfor gene_name, dna_sequence in gene_sequences.items():\n    gene_id = f\"G{gene_names.index(gene_name) + 1:03}\"  # Generate a unique gene ID\n    gene = Gene(name=gene_name, id=gene_id, coding_sequence=dna_sequence)\n    gene.add_length()  # Calculate length\n    gene.add_RNA()     # Convert to RNA\n    gene.add_protein_seq()  # Convert to protein sequence\n    gene_objects.append(gene)\n\n# Display the attributes of each gene object\nfor gene in gene_objects:\n    gene.print_attributes()\n\noutput:\n\nLength: 100\nCoding Sequence: GTTGAGATCCTCTAACTATGGCTGTACGGACTTCAATTAGTCGCGACTTCGGCAAGCTCCCCCATCTTTACCCAGACATCTATCCAATTGCATCACATCC\nRNA Sequence: CAACUCUAGGAGAUUGAUACCGACAUGCCUGAAGUUAAUCAGCGCUGAAGCCGUUCGAGGGGGUAGAAAUGGGUCUGUAGAUAGGUUAACGUAGUGUAGG\nProtein Sequence: VEILXLWLYGLQLVATSASSPIFTQTSIQLHHI\nGene Name: GeneB2\nGene ID: G002\nLength: 100\nCoding Sequence: GTTCGGACCCGTCTGTGCCGCTGAACGTCTACTGCCCGATAAGTCTTAGCCTCAAATATATACAGAAGAAAACATCATACTGCTGTTCGTGAAGTTCTGG\nRNA Sequence: CAAGCCUGGGCAGACACGGCGACUUGCAGAUGACGGGCUAUUCAGAAUCGGAGUUUAUAUAUGUCUUCUUUUGUAGUAUGACGACAAGCACUUCAAGACC\nProtein Sequence: VRTRLCRXTSTARXVLASNIYRRKHHTAVREVL\nGene Name: GeneC3\nGene ID: G003\nLength: 100\nCoding Sequence: TTCTACACTTATACTAGAACATGATTTCATTTCACCCAATAGATATACCGGGTGACTCATTTGGTAGGGTGGGATTGTAGAACGGTTACAACGGGTATGA\nRNA Sequence: AAGAUGUGAAUAUGAUCUUGUACUAAAGUAAAGUGGGUUAUCUAUAUGGCCCACUGAGUAAACCAUCCCACCCUAACAUCUUGCCAAUGUUGCCCAUACU\nProtein Sequence: FYTYTRTXFHFTQXIYRVTHLVGWDCRTVTTGM\nGene Name: GeneD4\nGene ID: G004\nLength: 100\nCoding Sequence: GACGGTGGCACATGACTCTGGGCTGTGCCATATAAAGGGGATAGCTCGCTGCCTTTGTTGCCGATTTGTCGTGGCGCTGCAGCTTGTCGGTGTTGTAATC\nRNA Sequence: CUGCCACCGUGUACUGAGACCCGACACGGUAUAUUUCCCCUAUCGAGCGACGGAAACAACGGCUAAACAGCACCGCGACGUCGAACAGCCACAACAUUAG\nProtein Sequence: DGGTXLWAVPYKGDSSLPLLPICRGAAACRCCN\nGene Name: GeneE5\nGene ID: G005\nLength: 100\nCoding Sequence: TAGTTGCAAGCGAGCGGGGTGGGTGCAGCTGTGTTAGCGATTCCGTTTCTGCCCACAACACTCCATGTCGAGCCATTATAAGATGAACGAGAAAAGCGGA\nRNA Sequence: AUCAACGUUCGCUCGCCCCACCCACGUCGACACAAUCGCUAAGGCAAAGACGGGUGUUGUGAGGUACAGCUCGGUAAUAUUCUACUUGCUCUUUUCGCCU\nProtein Sequence: XLQASGVGAAVLAIPFLPTTLHVEPLXDEREKR\nGene Name: GeneF6\nGene ID: G006\nLength: 100\nCoding Sequence: TCCCATTGTTGCACTCCGGACCTCAGATGCGGGGACCCCTAAAACGCTGTCCTTGTCACCCGTTTACAATGATGCTAACGTTGCGCAAATCTTTCACCTG\nRNA Sequence: AGGGUAACAACGUGAGGCCUGGAGUCUACGCCCCUGGGGAUUUUGCGACAGGAACAGUGGGCAAAUGUUACUACGAUUGCAACGCGUUUAGAAAGUGGAC\nProtein Sequence: SHCCTPDLRCGDPXNAVLVTRLQXCXRCANLSP\nGene Name: GeneG7\nGene ID: G007\nLength: 100\nCoding Sequence: AGGTGAACTAATCAGTTACCTTTCTTCTAACTGTTACCCCAAGTAGCAGACAAACAGTCGTGGAATCCGCAGCGATCCGTTGTCCGTCCATCTTACCCTG\nRNA Sequence: UCCACUUGAUUAGUCAAUGGAAAGAAGAUUGACAAUGGGGUUCAUCGUCUGUUUGUCAGCACCUUAGGCGUCGCUAGGCAACAGGCAGGUAGAAUGGGAC\nProtein Sequence: RXTNQLPFFXLLPQVADKQSWNPQRSVVRPSYP\nGene Name: GeneH8\nGene ID: G008\nLength: 100\nCoding Sequence: ACGGATTCAACAGGGCACACGTAACTACCTGATCGTGGTTAGGATCTTATTGGACGGGGTAATCGAGATGCTCTTATGTAGGCTCGAGTGTTGTCCATGG\nRNA Sequence: UGCCUAAGUUGUCCCGUGUGCAUUGAUGGACUAGCACCAAUCCUAGAAUAACCUGCCCCAUUAGCUCUACGAGAAUACAUCCGAGCUCACAACAGGUACC\nProtein Sequence: TDSTGHTXLPDRGXDLIGRGNRDALMXARVLSM\nGene Name: GeneI9\nGene ID: G009\nLength: 100\nCoding Sequence: TTTGTCACGCAGCGGCAACTCCACCGCCGGCTCTAGGCATGCCACGTTTCTGAACCATCTGACCACAGCTCGGACTGGATAAGGTCAGGTACGGATTCCC\nRNA Sequence: AAACAGUGCGUCGCCGUUGAGGUGGCGGCCGAGAUCCGUACGGUGCAAAGACUUGGUAGACUGGUGUCGAGCCUGACCUAUUCCAGUCCAUGCCUAAGGG\nProtein Sequence: FVTQRQLHRRLXACHVSEPSDHSSDWIRSGTDS\nGene Name: GeneJ0\nGene ID: G010\nLength: 100\nCoding Sequence: ATGTTCGGACACGGTGGCAATTACAACTCAAAGCCTCCAGACTGCTAGCTTGACAATTGGATCTTCCAGGCCACTAGACATGTACGTGATCCGCTTCAAC\nRNA Sequence: UACAAGCCUGUGCCACCGUUAAUGUUGAGUUUCGGAGGUCUGACGAUCGAACUGUUAACCUAGAAGGUCCGGUGAUCUGUACAUGCACUAGGCGAAGUUG\nProtein Sequence: MFGHGGNYNSKPPDCXLDNWIFQATRHVRDPLQ\n\ndefining the class phenotype:\n\nclass Phenotype:\n    def __init__(self, name, description):\n        self.name = name\n        self.description = description  # A string description\n        self.contributing_genes = []     # A list to hold gene objects\n\n    def add_genes(self, genes):\n        \"\"\"Add multiple gene objects to the contributing genes list.\"\"\"\n        try:\n            match genes:\n                case list():\n                    self.contributing_genes.extend(genes)\n                case _:\n                    raise ValueError(\"Input must be a list of gene objects.\")\n        except Exception as e:\n            print(f\"Error: {e}\")\n\n    def remove_genes(self, genes):\n        \"\"\"Remove gene objects from the contributing genes list.\"\"\"\n        try:\n            match genes:\n                case list():\n                    for gene in genes:\n                        if gene in self.contributing_genes:\n                            self.contributing_genes.remove(gene)\n                        else:\n                            print(f\"Gene {gene} not found in the contributing genes list.\")\n                case _:\n                    raise ValueError(\"Input must be a list of gene objects.\")\n        except Exception as e:\n            print(f\"Error: {e}\")\n\n    def append_description(self, extra_description):\n        \"\"\"Append extra lines to the description.\"\"\"\n        try:\n            match extra_description:\n                case str():\n                    self.description += \"\\n\" + extra_description\n                case _:\n                    raise ValueError(\"Extra description must be a string.\")\n        except Exception as e:\n            print(f\"Error: {e}\")\n\n    def replace_description(self, new_description):\n        \"\"\"Replace the current description with a new one.\"\"\"\n        try:\n            match new_description:\n                case str():\n                    self.description = new_description\n                case _:\n                    raise ValueError(\"New description must be a string.\")\n        except Exception as e:\n            print(f\"Error: {e}\")\n\n    def print_attributes(self):\n        \"\"\"Print the attributes of the phenotype and the genes.\"\"\"\n        print(f\"Phenotype Name: {self.name}\")\n        print(f\"Description: {self.description}\")\n        print(\"Contributing Genes:\")\n        if self.contributing_genes:\n            for gene in self.contributing_genes:\n                gene.print_attributes()\n        else:\n            print(\"  No contributing genes.\")\n\nmake the phenotype objects:\nphenotypes = []\nfor i in range(3):\n    # Randomly select 3 genes for each phenotype\n    selected_genes = random.sample(gene_objects, 3)\n    # Create the phenotype object with a name and description\n    phenotype = Phenotype(f\"phenotype_{i+1}\", f\"bad_phenotype_{i+1}\")\n    # Add the selected genes to the phenotype\n    phenotype.add_genes(selected_genes)\n    # Add the phenotype to the list of phenotypes\n    phenotypes.append(phenotype)\n\n# Print the attributes of the three phenotypes\nfor phenotype in phenotypes:\n    phenotype.print_attributes()\n    print(\"---\")\n\noutput:\n\nProtein Sequence: DGGTXLWAVPYKGDSSLPLLPICRGAAACRCCN\nGene Name: GeneI9\nGene ID: G009\nLength: 100\nCoding Sequence: TTTGTCACGCAGCGGCAACTCCACCGCCGGCTCTAGGCATGCCACGTTTCTGAACCATCTGACCACAGCTCGGACTGGATAAGGTCAGGTACGGATTCCC\nRNA Sequence: AAACAGUGCGUCGCCGUUGAGGUGGCGGCCGAGAUCCGUACGGUGCAAAGACUUGGUAGACUGGUGUCGAGCCUGACCUAUUCCAGUCCAUGCCUAAGGG\nProtein Sequence: FVTQRQLHRRLXACHVSEPSDHSSDWIRSGTDS\nGene Name: GeneG7\nGene ID: G007\nLength: 100\nCoding Sequence: AGGTGAACTAATCAGTTACCTTTCTTCTAACTGTTACCCCAAGTAGCAGACAAACAGTCGTGGAATCCGCAGCGATCCGTTGTCCGTCCATCTTACCCTG\nRNA Sequence: UCCACUUGAUUAGUCAAUGGAAAGAAGAUUGACAAUGGGGUUCAUCGUCUGUUUGUCAGCACCUUAGGCGUCGCUAGGCAACAGGCAGGUAGAAUGGGAC\nProtein Sequence: RXTNQLPFFXLLPQVADKQSWNPQRSVVRPSYP\n---\nPhenotype Name: phenotype_2\nDescription: bad_phenotype_2\nContributing Genes:\nGene Name: GeneG7\nGene ID: G007\nLength: 100\nCoding Sequence: AGGTGAACTAATCAGTTACCTTTCTTCTAACTGTTACCCCAAGTAGCAGACAAACAGTCGTGGAATCCGCAGCGATCCGTTGTCCGTCCATCTTACCCTG\nRNA Sequence: UCCACUUGAUUAGUCAAUGGAAAGAAGAUUGACAAUGGGGUUCAUCGUCUGUUUGUCAGCACCUUAGGCGUCGCUAGGCAACAGGCAGGUAGAAUGGGAC\nProtein Sequence: RXTNQLPFFXLLPQVADKQSWNPQRSVVRPSYP\nGene Name: GeneA1\nGene ID: G001\nLength: 100\nCoding Sequence: GTTGAGATCCTCTAACTATGGCTGTACGGACTTCAATTAGTCGCGACTTCGGCAAGCTCCCCCATCTTTACCCAGACATCTATCCAATTGCATCACATCC\nRNA Sequence: CAACUCUAGGAGAUUGAUACCGACAUGCCUGAAGUUAAUCAGCGCUGAAGCCGUUCGAGGGGGUAGAAAUGGGUCUGUAGAUAGGUUAACGUAGUGUAGG\nProtein Sequence: VEILXLWLYGLQLVATSASSPIFTQTSIQLHHI\nGene Name: GeneJ0\nGene ID: G010\nLength: 100\nCoding Sequence: ATGTTCGGACACGGTGGCAATTACAACTCAAAGCCTCCAGACTGCTAGCTTGACAATTGGATCTTCCAGGCCACTAGACATGTACGTGATCCGCTTCAAC\nRNA Sequence: UACAAGCCUGUGCCACCGUUAAUGUUGAGUUUCGGAGGUCUGACGAUCGAACUGUUAACCUAGAAGGUCCGGUGAUCUGUACAUGCACUAGGCGAAGUUG\nProtein Sequence: MFGHGGNYNSKPPDCXLDNWIFQATRHVRDPLQ\n---\nPhenotype Name: phenotype_3\nDescription: bad_phenotype_3\nContributing Genes:\nGene Name: GeneE5\nGene ID: G005\nLength: 100\nCoding Sequence: TAGTTGCAAGCGAGCGGGGTGGGTGCAGCTGTGTTAGCGATTCCGTTTCTGCCCACAACACTCCATGTCGAGCCATTATAAGATGAACGAGAAAAGCGGA\nRNA Sequence: AUCAACGUUCGCUCGCCCCACCCACGUCGACACAAUCGCUAAGGCAAAGACGGGUGUUGUGAGGUACAGCUCGGUAAUAUUCUACUUGCUCUUUUCGCCU\nProtein Sequence: XLQASGVGAAVLAIPFLPTTLHVEPLXDEREKR\nGene Name: GeneA1\nGene ID: G001\nLength: 100\nCoding Sequence: GTTGAGATCCTCTAACTATGGCTGTACGGACTTCAATTAGTCGCGACTTCGGCAAGCTCCCCCATCTTTACCCAGACATCTATCCAATTGCATCACATCC\nRNA Sequence: CAACUCUAGGAGAUUGAUACCGACAUGCCUGAAGUUAAUCAGCGCUGAAGCCGUUCGAGGGGGUAGAAAUGGGUCUGUAGAUAGGUUAACGUAGUGUAGG\nProtein Sequence: VEILXLWLYGLQLVATSASSPIFTQTSIQLHHI\nGene Name: GeneB2\nGene ID: G002\nLength: 100\nCoding Sequence: GTTCGGACCCGTCTGTGCCGCTGAACGTCTACTGCCCGATAAGTCTTAGCCTCAAATATATACAGAAGAAAACATCATACTGCTGTTCGTGAAGTTCTGG\nRNA Sequence: CAAGCCUGGGCAGACACGGCGACUUGCAGAUGACGGGCUAUUCAGAAUCGGAGUUUAUAUAUGUCUUCUUUUGUAGUAUGACGACAAGCACUUCAAGACC\nProtein Sequence: VRTRLCRXTSTARXVLASNIYRRKHHTAVREVL\n\ncheck sizes:\n\nimport sys\nprint(sys.getsizeof(gene_objects[0]))\n\nprint(sys.getsizeof(phenotypes[0]))\n\noutput:\n48\n48\nsys.getsizeof() outputs the shallow size of objects\nIn Python, when objects are passed as arguments to functions or assigned to other objects, they are passed by reference. This means that if you modify an object (e.g., a Gene object) that is part of a Phenotype object, the changes will be reflected in the Phenotype object as well, since they both refer to the same object in memory.\n\nimport copy\n\nphenotype_1_deepcopy = copy.deepcopy(phenotypes[0])\nphenotype_1_deepcopy.print_attributes()\n\nprint('the id of the genes of the deep copy should be different to the original:')\nprint(id(phenotypes[0].contributing_genes[0]))\nprint(id(phenotype_1_deepcopy.contributing_genes[0]))\n\noutput:\nPhenotype Name: phenotype_1\nDescription: bad_phenotype_1\nContributing Genes:\nGene Name: GeneD4\nGene ID: G004\nLength: 100\nCoding Sequence: GACGGTGGCACATGACTCTGGGCTGTGCCATATAAAGGGGATAGCTCGCTGCCTTTGTTGCCGATTTGTCGTGGCGCTGCAGCTTGTCGGTGTTGTAATC\nRNA Sequence: CUGCCACCGUGUACUGAGACCCGACACGGUAUAUUUCCCCUAUCGAGCGACGGAAACAACGGCUAAACAGCACCGCGACGUCGAACAGCCACAACAUUAG\nProtein Sequence: DGGTXLWAVPYKGDSSLPLLPICRGAAACRCCN\nGene Name: GeneI9\nGene ID: G009\nLength: 100\nCoding Sequence: TTTGTCACGCAGCGGCAACTCCACCGCCGGCTCTAGGCATGCCACGTTTCTGAACCATCTGACCACAGCTCGGACTGGATAAGGTCAGGTACGGATTCCC\nRNA Sequence: AAACAGUGCGUCGCCGUUGAGGUGGCGGCCGAGAUCCGUACGGUGCAAAGACUUGGUAGACUGGUGUCGAGCCUGACCUAUUCCAGUCCAUGCCUAAGGG\nProtein Sequence: FVTQRQLHRRLXACHVSEPSDHSSDWIRSGTDS\nGene Name: GeneG7\nGene ID: G007\nLength: 100\nCoding Sequence: AGGTGAACTAATCAGTTACCTTTCTTCTAACTGTTACCCCAAGTAGCAGACAAACAGTCGTGGAATCCGCAGCGATCCGTTGTCCGTCCATCTTACCCTG\nRNA Sequence: UCCACUUGAUUAGUCAAUGGAAAGAAGAUUGACAAUGGGGUUCAUCGUCUGUUUGUCAGCACCUUAGGCGUCGCUAGGCAACAGGCAGGUAGAAUGGGAC\nProtein Sequence: RXTNQLPFFXLLPQVADKQSWNPQRSVVRPSYP\nthe id of the genes of the deep copy should be different to the original:\n135961870136992\n135961869732160",
    "crumbs": [
      "Session-2",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Recap Exercise</span>"
    ]
  },
  {
    "objectID": "materials/09-session-1-recap-and-exercises-wa.html#conclusion",
    "href": "materials/09-session-1-recap-and-exercises-wa.html#conclusion",
    "title": "11  Recap Exercise",
    "section": "11.2 Conclusion",
    "text": "11.2 Conclusion\nHopefully that was a fun exercise to go over everything we have done so far! Let’s now move on to today’s topics.\n\n\n\n\n\n\nKey Points\n\n\n\n\nBy completing the above exercise, you should be able to independently apply the concepts covered yesterday\nIf there is anything you found difficult, go back to the relevant sections and recap the material",
    "crumbs": [
      "Session-2",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Recap Exercise</span>"
    ]
  },
  {
    "objectID": "materials/10-Installing-Python-packages.html",
    "href": "materials/10-Installing-Python-packages.html",
    "title": "12  Installing Python Packages",
    "section": "",
    "text": "12.1 Installing Packages with pip\npip (Python’s default package installer) is used to install packages from the Python Package Index (PyPI), a repository of software for Python.\nYou can install packages by running the following command in your terminal or command prompt:\npip install package_name\nFor example, to install the numpy library:\npip install numpy\nYou can install a specific version of a package by specifying the version number:\npip install numpy==1.21.0\nTo update a package to the latest version:\npip install --upgrade package_name\nPros of Using pip:\nCons of Using pip:",
    "crumbs": [
      "Session-2",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Installing Python Packages</span>"
    ]
  },
  {
    "objectID": "materials/10-Installing-Python-packages.html#installing-packages-with-pip",
    "href": "materials/10-Installing-Python-packages.html#installing-packages-with-pip",
    "title": "12  Installing Python Packages",
    "section": "",
    "text": "Wide range of packages: Since pip installs from PyPI, it gives access to a vast collection of Python libraries.\nLightweight: Pip is small and fast, suitable for installing Python-only packages.\nFlexible: Pip works well with virtual environments (e.g., venv or virtualenv) to isolate dependencies.\n\n\n\nDependency management: Pip doesn’t handle package dependencies as robustly as conda. This can result in conflicts or missing dependencies.\nPython-only: Pip is mainly designed for Python packages. If a package has non-Python dependencies, you may have to install them manually.",
    "crumbs": [
      "Session-2",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Installing Python Packages</span>"
    ]
  },
  {
    "objectID": "materials/10-Installing-Python-packages.html#installing-packages-with-conda",
    "href": "materials/10-Installing-Python-packages.html#installing-packages-with-conda",
    "title": "12  Installing Python Packages",
    "section": "12.2 Installing Packages with conda",
    "text": "12.2 Installing Packages with conda\nconda is a package manager included with the Anaconda distribution, which is widely used for data science, scientific computing, and machine learning. It manages both Python and non-Python dependencies, making it a more versatile option in certain environments.\nRather than using the Anaconda distribution, (which though good comes with a lot unnecessary packages) install conda directly. New lightweight faster alternatives to conda, mamba and micromamba are now widely used. They work in the same way with the same commands.\nHow to Install a Package with conda\nTo install a package using conda, you would use:\nconda install package_name\nFor example, to install numpy:\nconda install numpy\nTo install a specific version of a package using conda:\nconda install numpy=1.21.0\nTo update an installed package to the latest version:\nconda update package_name\nGenerally, you would create an specific environment for example to python projects, with the packages you need:\nconda create --name env_name\nconda env list\nconda activate env_name\nconda install -c conda-forge package_name \n#conda-forge is a channel with generally more up to date packages\nconda deactivate\nPros of Using conda:\n\nCross-language package management: conda can install packages, libraries, and software, that are written in Python, C, C++, R, or other languages.\nHandles non-Python dependencies: Unlike pip, conda can install non-Python dependencies such as libc, OpenBLAS, or other compiled libraries.\nRobust dependency resolution: conda provides more sophisticated dependency resolution, reducing the risk of package conflicts.\nEnvironment management: conda simplifies creating isolated environments, allowing you to easily manage multiple versions of Python, or other libraries, on the same system.\n\nCons of Using conda:\n\nLimited packages: Although conda has its own package repository, it doesn’t have access to all Python packages in PyPI. Sometimes, you might need to fall back on pip.\nSlower: Conda can be slower and heavier than pip, especially when solving complex package dependencies.\nLarger installation: The Anaconda distribution is large, as it comes with many pre-installed libraries. This might be unnecessary if you only need specific packages.\nMultiple environments use more space: Having multiple different environments with different software versions can take up a lot of space (though unfortunately it is often necessary)\n\nOverview of using conda:\n\n\n\n\n\n\n\nFeature\nDescription\n\n\n\n\nIsolation\nEach environment has its own packages and dependencies, avoiding conflicts between projects\n\n\nReproducibility\nEnvironments can be exported to environment.yml files, ensuring consistent setups across systems\n\n\nPackage Management\nConda manages not just Python packages, but also dependencies for languages like R, C++, etc\n\n\nMultiple Environments\nSupports creating and switching between environments for different projects with different setups\n\n\nCreating an Environment\nconda create --name myenv python=3.9 – Creates a new environment with a specific Python version\n\n\nActivating an Environment\nconda activate myenv – Activates the environment for use\n\n\nInstalling Packages\nconda install numpy pandas – Installs packages into the active environment\n\n\nListing Environments\nconda env list – Lists all environments\n\n\nExporting an Environment\nconda env export &gt; environment.yml – Exports environment setup to a file\n\n\nCreating from yml File\nconda env create -f environment.yml – Recreates environment from a .yml file\n\n\nRemoving an Environment\nconda env remove --name myenv – Deletes an environment\n\n\n\nNote that conda and other environment and package managers DO NOT isolate files on the filesystem. You can access and work with files irrespective of the conda environment it was created in.",
    "crumbs": [
      "Session-2",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Installing Python Packages</span>"
    ]
  },
  {
    "objectID": "materials/10-Installing-Python-packages.html#combining-pip-and-conda",
    "href": "materials/10-Installing-Python-packages.html#combining-pip-and-conda",
    "title": "12  Installing Python Packages",
    "section": "12.3 Combining pip and conda",
    "text": "12.3 Combining pip and conda\nIn some cases, you may need to use both pip and conda in the same environment. For example, if a package isn’t available via conda, you can use pip to install it.\nExample: Using conda and pip together:\n\nCreate a new conda environment:\n\nconda create -n myenv python=3.9\n\nActivate the environment:\n\nconda activate myenv\n\nInstall a package with conda:\n\nconda install numpy\n\nInstall a package with pip:\n\npip install some_package_not_in_conda\nImportant Note:\n\nInstall with conda first: It’s generally recommended to install packages with conda first. If the package is not available, then use pip as a fallback to minimize conflicts.",
    "crumbs": [
      "Session-2",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Installing Python Packages</span>"
    ]
  },
  {
    "objectID": "materials/10-Installing-Python-packages.html#summary-when-to-use-pip-or-conda",
    "href": "materials/10-Installing-Python-packages.html#summary-when-to-use-pip-or-conda",
    "title": "12  Installing Python Packages",
    "section": "12.4 Summary: When to Use pip or conda",
    "text": "12.4 Summary: When to Use pip or conda\n\n\n\n\n\n\n\n\nCriteria\npip\nconda\n\n\n\n\nPrimary Use\nPython packages from PyPI\nCross-language package management\n\n\nDependency Resolution\nBasic (manual at times)\nAdvanced (automatic)\n\n\nNon-Python Dependencies\nNot handled\nHandled\n\n\nSpeed and Performance\nLightweight and fast\nSlower, but more robust\n\n\nAccess to Packages\nVast library via PyPI\nLimited to conda channels\n\n\nEnvironments\nWorks with venv or virtualenv\nBuilt-in environment management\n\n\nBest For\nPure Python projects\nData science, scientific computing",
    "crumbs": [
      "Session-2",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Installing Python Packages</span>"
    ]
  },
  {
    "objectID": "materials/10-Installing-Python-packages.html#using-command-line-in-jupyter-notebooks-or-python-console",
    "href": "materials/10-Installing-Python-packages.html#using-command-line-in-jupyter-notebooks-or-python-console",
    "title": "12  Installing Python Packages",
    "section": "12.5 Using Command Line in Jupyter Notebooks or Python Console",
    "text": "12.5 Using Command Line in Jupyter Notebooks or Python Console\nWhen working in Jupyter notebooks or the Python console, you can use command-line operations to install and manage Python packages. This can be done using either pip or conda, depending on your setup.\nYou can run shell commands directly in a Jupyter notebook by prefixing them with an exclamation mark (!). Here’s how to install packages using pip:\n\nwith pip\n\nTo install a package (e.g., numpy), you can run the following command in a cell:\n!pip install numpy\n\n\nwith conda\n\nTo install a package (e.g., numpy), you can run:\n!conda install numpy -y\n\n\n\n\n\n\nExercise 1\n\n\n\n\n\n\nLevel: \n\nInstall pandas and numpy\nTry to install pandas and numpy using mamba , conda or pip You should have already installed mamba using the setup instructions",
    "crumbs": [
      "Session-2",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Installing Python Packages</span>"
    ]
  },
  {
    "objectID": "materials/10-Installing-Python-packages.html#summary",
    "href": "materials/10-Installing-Python-packages.html#summary",
    "title": "12  Installing Python Packages",
    "section": "12.6 Summary",
    "text": "12.6 Summary\nUsing Package managers can be very useful to enable you to easily install, update, and manage software packages (libraries or programs) on your computer. They automate the process, saving you time and effort. Virtual environments are isolated environments that allow you to manage dependencies and packages for different projects separately. They can be used to create specific setups for each project without interference from global installations.\n\n\n\n\n\n\nKey Points\n\n\n\nPackage and environment managers like Conda enable:\n\nEasy Installation: Quickly install software with simple commands instead of downloading and configuring manually.\nDependency Management: Automatically handle and install any additional software that your main software needs to run (dependencies).\nVersion Control: Manage different versions of packages to ensure compatibility and avoid conflicts.\nUpdates: Easily update installed software to the latest versions with a single command.\nEnvironment Isolation: Create separate environments for different projects, preventing conflicts between package versions.",
    "crumbs": [
      "Session-2",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Installing Python Packages</span>"
    ]
  },
  {
    "objectID": "materials/11-working-with-files.html",
    "href": "materials/11-working-with-files.html",
    "title": "13  Working with Files in Python",
    "section": "",
    "text": "13.1 Working Directory\nWorking with files is simple in python. Many packages have their own built-in file reading and writing functions including for example ‘pandas’ which we will look at next. Here we use the built-in open function.\nA working directory is the directory within the file system where your program will use as a default to look for and read files or output files. It easier than always defining absolute file paths and can allow code to be transferred.\nWhen running python scripts from the console, the working directory is the one where you launched the script from.\nThe os module can be used in Jupyter Notebooks to check the working directory and change it.\nGet working Directory:\nChange working Directory:\nYou can also use the magic command:\nMagic commands in Jupyter Notebooks can be super useful. We will not look at them further here, but also note that they cannot be used ouside the iPython Kernel\nYou can also set default working directory in the config file. We will not go over this here (and I myself tend not to work this way - although I also don’t often use Jupyter Notebooks).\nI recommend having scripts and data in the same directory, or a subdirectory of the project directory. My common setup might be:",
    "crumbs": [
      "Session-2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Working with Files in Python</span>"
    ]
  },
  {
    "objectID": "materials/11-working-with-files.html#working-directory",
    "href": "materials/11-working-with-files.html#working-directory",
    "title": "13  Working with Files in Python",
    "section": "",
    "text": "import os\nprint(os.getcwd())  #current working directory\n\nos.chdir('/path/to/directory')\n\n%cd /path/to/directory\n\n\n\n/home/user/project/\n    ├── data/\n    │   └── dataset.csv\n    ├── scripts/\n    |   └── analysis.py\n    ├── logs/\n    │   └── error-log.log\n    │   └── output-log.log\n    └── output/\n        └── output.csv",
    "crumbs": [
      "Session-2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Working with Files in Python</span>"
    ]
  },
  {
    "objectID": "materials/11-working-with-files.html#opening-and-closing-files-in-python",
    "href": "materials/11-working-with-files.html#opening-and-closing-files-in-python",
    "title": "13  Working with Files in Python",
    "section": "13.2 Opening and closing files in python",
    "text": "13.2 Opening and closing files in python\nYou can open files in different modes using the open() function. The common modes include:\n\n'r': Read (default)\n'w': Write (overwrites the file if it exists)\n'a': Append (adds content to the end of the file)\n'b': Binary mode (for non-text files)\n'x': Exclusive creation (fails if the file already exists)\n\nExample:\n# Open the file in read mode\nfile = open('dna_sequence.txt', 'r')\n\n# Read the contents of the file into a string\ndna_sequence = file.read()\n\n# Close the file\nfile.close()\n\n# The dna_sequence variable now holds the content of dna_sequence.txt\nprint(dna_sequence)  # This will display the content of the file\n\nfile.readlines() will return a list with each line:\nfile = open('dna_sequences.txt', 'r')\ndna_sequences = file.readlines()\nfile.close()\nUsing for loops to iterate line by line:\nfile = open('dna_sequences.txt', 'r')\nfor line in file:\n    # Strip trailing whitespace or newline characters from the end of each line\n    dna_sequence = line.strip()\n    print(dna_sequence)  # Process or print the current line\nfile.close()\nThis method is memory-efficient, especially for large files, since it doesn’t load the entire file into memory at once.\nConsider the problems with working with files this way:\n\n\n\n\n\n\nExercise 1 - Discussion: Exceptions after open()\n\n\n\n\n\n\nLevel: \nIf an exception occurs after open() what will happen? What have you already learnt as a method to stop this?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nThe file will never close properly - you could use try ,except , finally. The with statement presented in the next section is a better way to deal with this.",
    "crumbs": [
      "Session-2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Working with Files in Python</span>"
    ]
  },
  {
    "objectID": "materials/11-working-with-files.html#using-with-when-working-with-files",
    "href": "materials/11-working-with-files.html#using-with-when-working-with-files",
    "title": "13  Working with Files in Python",
    "section": "13.3 Using with when working with files:",
    "text": "13.3 Using with when working with files:\nUsing the with statement is a better way to work with files in Python as it ensures that files are properly opened and closed.\nExample:\nwith open('dna_sequence.txt', 'r') as file:\n    for line in file:\n        # Strip the newline character from each line and print it\n        dna_sequence = line.strip()\n        print(dna_sequence)\n\nNote it uses the same kind of syntax as for loops and conditionals\nwith does this by working with a context manager. The open() function returns a fileobject which has the .__enter___() and .__exit__() methods. You can read more about this in your own time.",
    "crumbs": [
      "Session-2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Working with Files in Python</span>"
    ]
  },
  {
    "objectID": "materials/11-working-with-files.html#aside-garbage-collection",
    "href": "materials/11-working-with-files.html#aside-garbage-collection",
    "title": "13  Working with Files in Python",
    "section": "13.4 Aside: Garbage collection",
    "text": "13.4 Aside: Garbage collection\nGarbage collection frees memory by cleaning up objects and variables that are no longer needed.\nPython does this automatically through reference counting and generational garbage collection.\nYou can interact with this using the gc module.",
    "crumbs": [
      "Session-2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Working with Files in Python</span>"
    ]
  },
  {
    "objectID": "materials/11-working-with-files.html#writing-to-a-file",
    "href": "materials/11-working-with-files.html#writing-to-a-file",
    "title": "13  Working with Files in Python",
    "section": "13.5 Writing to a file",
    "text": "13.5 Writing to a file\nThe same methods are used to write to a file:\nWrite to a new file or replace an existing file\nWriting to a new file or overwriting an existing file is simple:\nwith open('sequences.txt', 'w') as file:\n    file.write(\"ACGTGCTTCCAAACGTA\\n\")\n    file.write(\"ACGTGCTTCCAAACGTA\\n\")\n\nfile.writelines(): Takes an iterable (like a list) and writes each item to the file. You can also use for loops.\n\nthe \\n is needed when manually adding lines.\n\nAppending to an existing file\nThis is exactly the same however you need to replace 'w' with 'a' for append mode.\nbinary files Use the 'wb' for writing binaries for example.\n\n\n\n\n\n\nExercise 2 - Reading and writing files\n\n\n\n\n\n\nLevel: \nUse the above to first write something to a file. Then read and append to the file.",
    "crumbs": [
      "Session-2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Working with Files in Python</span>"
    ]
  },
  {
    "objectID": "materials/11-working-with-files.html#moving-files",
    "href": "materials/11-working-with-files.html#moving-files",
    "title": "13  Working with Files in Python",
    "section": "13.6 Moving files",
    "text": "13.6 Moving files\nThe shutil module can be used to move files in python.\nimport shutil\nimport os\n\n# Define paths\nsource_file = 'source_folder/file.txt' \ndestination_file = 'destination_folder/file.txt' \n\n# Create the destination folder if it doesn't exist\nos.makedirs(os.path.dirname(destination_file), exist_ok=True)\n\n# Move the file\nshutil.move(source_file, destination_file)\n\n\nThe same can be used to move directories",
    "crumbs": [
      "Session-2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Working with Files in Python</span>"
    ]
  },
  {
    "objectID": "materials/11-working-with-files.html#summary",
    "href": "materials/11-working-with-files.html#summary",
    "title": "13  Working with Files in Python",
    "section": "13.7 Summary",
    "text": "13.7 Summary\nIt is important to be able to manipulate files in python. Many packages like pandas come with functions to read and write specific file types. See the following file types and modules to work with them:\n\n\n\n\n\n\n\n\n\nFile Type\nExtension(s)\nDescription\nModules\n\n\n\n\nText File\n.txt\nPlain text files that contain unformatted text.\nBuilt-in open(), io\n\n\nCSV File\n.csv\nComma-separated values, files used to store tabular data.\ncsv, pandas\n\n\nTSV File\n.tsv\nTab-separated values, files used to store tabular data, similar to CSV.\ncsv, pandas\n\n\nJSON File\n.json\nJavaScript Object Notation, a lightweight data interchange format.\njson, pandas\n\n\nXML File\n.xml\nExtensible Markup Language, used to store structured data.\nxml.etree.ElementTree, lxml\n\n\nExcel File\n.xls, .xlsx\nMicrosoft Excel files for storing spreadsheet data.\npandas, openpyxl, xlrd\n\n\nPickle File\n.pkl, .pickle\nSerialized Python objects for saving and loading Python data types.\npickle\n\n\nSQLite Database\n.sqlite, .db\nLightweight database files used with SQLite, a C-based database engine.\nsqlite3, pandas\n\n\nHDF5 File\n.h5, .hdf5\nHierarchical Data Format for storing large amounts of data efficiently.\nh5py, pandas\n\n\nParquet File\n.parquet\nColumnar storage file format optimized for use with big data processing.\npyarrow, pandas\n\n\nZarr File\n.zarr\nChunked, compressed N-dimensional arrays for large datasets, designed for cloud storage.\nzarr, xarray\n\n\nHTML File\n.html, .htm\nHyperText Markup Language files used for web pages.\nhtml.parser, BeautifulSoup\n\n\nMarkdown File\n.md\nPlain text files formatted using Markdown for easy reading and writing.\nmarkdown, Mistune\n\n\nLog File\n.log\nText files that record events or messages from applications.\nBuilt-in open(), logging\n\n\nImage Files\n.jpg, .jpeg, .png, .gif\nCommon image formats for graphics.\nPIL, OpenCV, imageio\n\n\nAudio Files\n.mp3, .wav, .ogg\nCommon audio formats for music and sound.\npydub, wave, soundfile\n\n\nVideo Files\n.mp4, .avi, .mov\nCommon video formats for visual media.\nmoviepy, opencv, imageio\n\n\nArchive Files\n.zip, .tar, .gz\nCompressed files for reducing file size and bundling multiple files.\nzipfile, tarfile, shutil\n\n\nPDF File\n.pdf\nPortable Document Format, used for presenting documents.\nPyPDF2, pdfplumber, reportlab\n\n\nFASTA File\n.fasta, .fa\nText-based format for representing nucleotide or peptide sequences.\nBioPython\n\n\nGenBank File\n.gb, .gbk\nFormat for storing genomic data, including sequence and annotation.\nBioPython\n\n\nAlignment File\n.maf\nFiles that store multiple sequences aligned against each other.\nBioPython\n\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nIt is essential to be able to work with different file types\nIt is better to use the with method when working with files to handle opening and closing files\nMany modules can be used to work with different file types",
    "crumbs": [
      "Session-2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Working with Files in Python</span>"
    ]
  },
  {
    "objectID": "materials/12-numpy-array-and-pandas-dataframes-wa.html",
    "href": "materials/12-numpy-array-and-pandas-dataframes-wa.html",
    "title": "14  NumPy Arrays and pandas Dataframes",
    "section": "",
    "text": "14.1 Comparison of ‘NumPy’ and ‘pandas’\n‘pandas’ dataframes and ‘NumPy’ arrays are widely used in data science in Python. The documentation for both modules and online resources available are very good. Rather than explaining every single feature, I will instead compare the two modules and when to use them. You will then explore the documentation and find out how to do some common operations in ‘pandas’ and ‘NumPy’, with some test data.\nGenerally speaking ‘NumPy’ arrays and ‘pandas’ dataframes are used for very different things, but there is cross functionality. Ultimately it depends on the data and what kinds of operations you want to use it for.",
    "crumbs": [
      "Session-2",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>NumPy Arrays and pandas Dataframes</span>"
    ]
  },
  {
    "objectID": "materials/12-numpy-array-and-pandas-dataframes-wa.html#comparison-of-numpy-and-pandas",
    "href": "materials/12-numpy-array-and-pandas-dataframes-wa.html#comparison-of-numpy-and-pandas",
    "title": "14  NumPy Arrays and pandas Dataframes",
    "section": "",
    "text": "Feature\npandas\nNumPy\n\n\n\n\nData Structure\nDataFrame (2D, labelled) and Series (1D)\nndarray (N-dimensional array)\n\n\nData Types\nSupports mixed data types in columns\nHomogeneous data types in columns\n\n\nIndexing\nLabelled indexing (row/column labels)\nInteger-based indexing\n\n\nMemory Usage\nGenerally more memory overhead; can be managed by chunking and changing column dtypes\nMore memory efficient due to contiguous memory; optimized over time\n\n\nSpeed\nSlower for numerical operations due to overhead; performance has improved with updates\nFaster for numerical operations; optimized for speed in core calculations\n\n\nData Manipulation\nRich functionality for data manipulation; has expanded over time\nPrimarily for numerical computation; core functionality remains stable\n\n\nHandling Missing Data\nBuilt-in support for NaN values\nLimited support; must handle manually\n\n\nAggregation\nBuilt-in functions for grouping and aggregating\nRequires custom functions\n\n\nData Visualization\nBuilt-in integration with visualization libraries\nNot designed for direct visualization\n\n\nUse Case\nIdeal for data analysis with mixed types\nIdeal for numerical and scientific computing\n\n\nOverhead Changes\nIncreased overhead with more features (e.g., complex indexing and grouping operations)\nFocus on minimizing overhead while maintaining performance\n\n\nChunking Data\nSupports chunking with functions like pd.read_csv() for large datasets\nRequires manual implementation; typically works with whole arrays",
    "crumbs": [
      "Session-2",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>NumPy Arrays and pandas Dataframes</span>"
    ]
  },
  {
    "objectID": "materials/12-numpy-array-and-pandas-dataframes-wa.html#the-same-data-in-pandas-and-numpy",
    "href": "materials/12-numpy-array-and-pandas-dataframes-wa.html#the-same-data-in-pandas-and-numpy",
    "title": "14  NumPy Arrays and pandas Dataframes",
    "section": "14.2 The Same Data in ‘pandas’ and ‘NumPy’",
    "text": "14.2 The Same Data in ‘pandas’ and ‘NumPy’\nGene Sequence Length Data (Different Data Types)\nUsing ‘pandas’\nimport pandas as pd\n\n# Example data\ndata = {\n    'Gene Name': ['Gene1', 'Gene2', 'Gene3'],  # Strings\n    'Sequence Length': [1200, 1500, 2000],      # Integers\n    'Description': ['Long gene', 'Medium gene', 'Short gene']  # Strings\n}\n\ndf_genes = pd.DataFrame(data)\nprint(\"Pandas DataFrame:\")\nprint(df_genes)\nUsing ‘NumPy’ Structured Array\n\nimport numpy as np\n\n# Define a structured data type\ndtype = [('Gene Name', 'U10'), ('Sequence Length', 'i4'), ('Description', 'U15')]\n\n# Create an array with mixed data types\nnp_genes = np.array([\n    ('Gene1', 1200, 'Long gene'),\n    ('Gene2', 1500, 'Medium gene'),\n    ('Gene3', 2000, 'Short gene')\n], dtype=dtype)\n\nprint(\"\\nNumPy Structured Array:\")\nprint(np_genes)\n\nconverting data to a single type\n\n\n\n\n\n\nExercise 1 - Encoding\n\n\n\n\n\n\nLevel: \nWhy might you want to convert all the data to the same data type?\nHow would you encode all the above in a single data type so that it can be held as a standard ‘NumPy’ array?\n\n\n\n\ne.g. machine learning:\nPreparing data is crucial for building effective machine learning models. Encoding is when you convert categorical and other data into numerical formats, which algorithms can easily interpret. Common encoding techniques include:\nOne-Hot Encoding: Converts categorical variables into a binary matrix representation, where each category is represented by a unique binary vector.\nLabel Encoding: Assigns each unique category an integer label, which is suitable for ordinal data but can introduce unintended ordinal relationships in nominal data.\nChanging Data Types involves converting data into formats that are more suitable for analysis.",
    "crumbs": [
      "Session-2",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>NumPy Arrays and pandas Dataframes</span>"
    ]
  },
  {
    "objectID": "materials/12-numpy-array-and-pandas-dataframes-wa.html#numpy-and-pandas-documentation",
    "href": "materials/12-numpy-array-and-pandas-dataframes-wa.html#numpy-and-pandas-documentation",
    "title": "14  NumPy Arrays and pandas Dataframes",
    "section": "14.3 ‘NumPy’ and ‘pandas’ Documentation",
    "text": "14.3 ‘NumPy’ and ‘pandas’ Documentation\nThe ‘NumPy’ and ‘pandas’ documentation is very good and both modules are very widely used! For this reason I have not given any more examples here. When you start coding more, you must use the resources and documentation to solve your own challenges.\nNumpy Documentation:\nhttps://numpy.org/doc/\nPandas Documentation:\nhttps://pandas.pydata.org/docs/\nhttps://pandas.pydata.org/Pandas_Cheat_Sheet.pdf\n\n\n\n\n\n\nExercise 2 - Uses of pandas and numpy\n\n\n\n\n\n\nLevel: \nLook through the docs and discuss the functions of ‘pandas’ and ‘NumPy’.\nGive two biological examples of types of data analysis when you would use ‘NumPy’ arrays and two when you would use ‘pandas’ dataframes.\nFor your use cases, what would the most important functions be?\n\n\n\n\n\n\n\n\n\n\nExercise 3 - Encoding and memory usage\n\n\n\n\n\n\nLevel: \nCreate the ‘pandas’ dataframe and ‘NumPy’ array shown in the above example.\nImplement encoding for the ‘NumPy’ array and ‘pandas’ dataframe.\nCompare the deep size of the arrays and dataframes using functions found in the documentation.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Find the size (memory usage) of the DataFrame\ndf_memory = df.memory_usage(deep=True).sum()  # deep=True gives a more accurate estimate\nprint(f\"Size of Pandas DataFrame: {df_memory} bytes\")\n\n# Find the size (memory usage) of the NumPy array\nnumpy_memory = numpy_array.nbytes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 4 - Numpy Array Task\n\n\n\n\n\n\nLevel: \nLoad the two DNA sequences in the dataset named DNA-seq.txt into python.\nImplement the dot plot in a ‘NumPy’ array. i.e. place one sequence along the top of a grid and the other along the side and put a 1 in the grid wherever the characters match.\nFind the number of non-overlapping matching sequences on sequence1 where there are more than 5 bases matching sequence2 in a row.\nFind the number of independent matching sequences where there are more than 10 bases matching in a row. What about more than 20? i.e. if seq1(i) = seq2(j) and seq1(i+1) = seq2(j+1) then it is part of the same matching sequence. Please ask if this is unclear.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nAnswer code:\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nwith open('DNA-seq.txt', 'r') as file:\n    sequences = file.readlines()\n    # Assuming the first two lines are the sequences\nseq1 = sequences[0]\nseq2 = sequences[1]\n\nprint(seq1)\nprint(seq2)\nprint(len(seq1))\nprint(len(seq2))\n\n#seq1 = \"TAGCTAGCTTGACGCTGATCGGACGCGTTGGTTCGAAG\"\n#seq2 = \"AGTCGGACTTCGCTAGGACTTCGGTCGACCGGACGTGCC\"\n\ndef create_dot_plot(seq1, seq2):\n    try:\n        rows = len(seq1)\n        cols = len(seq2)\n        dot_plot = np.zeros((rows, cols), dtype=int)\n\n        for i in range(rows):\n            for j in range(cols):\n                if seq1[i] == seq2[j]:\n                    dot_plot[i][j] = 1\n\n        return dot_plot\n\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return None\n\ndot_plot = create_dot_plot(seq1, seq2)\nprint(dot_plot)\n#plt.imshow(dot_plot)\n#plt.show()\n\n\ndef count_matching_regions(seq1, seq2, min_length):\n    count = 0\n    match_length = 0\n    dot_plot = create_dot_plot(seq1, seq2)\n\n# I have purposely not commented this code very well - try to figure out what I am doing - the prints commented out may help you\n    try:\n\n      for i in range(len(seq1)):\n        j = 0\n        #print(i)\n        while j &lt;= (len(seq2)-1) and i &lt;= (len(seq1)-1):\n                #print(i,j)\n                if dot_plot[i,j] == 1:\n                  match_length += 1\n                  i += 1\n                  j += 1\n                else:\n                  i += 1\n                  j += 1\n\n                # Check if we are at the end of the sequences or next characters don't match\n                  if (match_length &gt; 0) or i == len(seq1) or j == len(seq2):\n                      if match_length &gt;= min_length:\n                          count += 1\n                          #print(count)\n                          match_length = 0  # Reset match length after counting\n                      else:\n                          match_length = 0  # Reset if there is no match\n\n      for j in range(1,len(seq2)):\n        i = 0\n        while j &lt;= (len(seq2)-1) and i &lt;= (len(seq1)-1):\n                #print(i,j)\n                if dot_plot[i,j] == 1:\n                  match_length += 1\n                  i += 1\n                  j += 1\n                else:\n                  i += 1\n                  j += 1\n\n                # Check if we are at the end of the sequences or next characters don't match\n                  if (match_length &gt; 0) or i == len(seq1) or j == len(seq2):\n                      if match_length &gt;= min_length:\n                          count += 1\n                          #print(count)\n                          match_length = 0  # Reset match length after counting\n                      else:\n                          match_length = 0  # Reset if there is no match\n\n      return count\n\n\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\n        return None\n\nmatching_20 = count_matching_regions(seq1, seq2, 20)\nmatching_10 = count_matching_regions(seq1, seq2, 10)\nprint(f\"Number of matching regions with length &gt;= 20: {matching_20}\")\nprint(f\"Number of matching regions with length &gt;= 10: {matching_10}\")\n\n\nAnswer output:\n\nTAGCTAGCTTGACGCTGATCGGACGCGTTGGTTCGAAGCTTGAGATTCATAGCTGGGCGTACCTTACCCGTTGAAGACGACTTCCGAAAGGTTTAGGAACGTGCTACGAGTGTATCGGGACGTAACGGGATGACTGTAGACTATGGTTTCGGGGTGTAGGCGGCTTTGAACTCCGAGAAACCTGAGTGGCGACTTAGCCCGCCGTGTCGAATAGGAGCTCAGTTCATTCAGGATCGTCTTGGCGTTGGCAGTACGGCTCCCGGGGTCCGTCGAGGGTCACGTCGGTCCGAGCTGCTTTCCCGATATGCTACTTCGCCCGTCACTAGGTGTTTCGACCGATCGCTGGTACGCTCAGTGAGGTTGCCAGGCGTGAAACTACGCTTAGGCTTGCCGAGTGCTCCTTAGAGGTGCACCAGTAGGCGCGCGTATTGACTTACGACTTCTGTGTGACGCGAGCGACATAGCGCGCGTGGACTACAGCCTGGATCGGGCTGCGACTTGGTTGTGCAGTCGACGTGGCAGGATTGTGATCGACGATTCTTACCCGGGGTTCGACTAGGACTTTGACTGCGGTAGCCCTTGGGGAGGTTGCGGAGAGGACGACTTGGTGAGCCCGATTGATGCTGAGTCGCCAGGCTTGGGGACTTGATCGGACTTCGTAGCCGACTTGCGAGCTCGGTGCTGAGGCGGATGCTCGACTCGAGTAGGGGGTCGATCCGAGCGGTTAGGCGACCGACGTACGTGTTGGGTCGCGATGGCAGAGTGGGGCGACAGTACCGCTGTTGGCACGGACGTTAGTCGATGGGTGACCCGGCTCAGTCTTGTGATCGACTGATGCGGGTAGTACCTTGGACTACGATCGCGGGTGCGTGACTTCCGACGACCGCTTAGGCCGAGTACGTTGTGCTTCACGTCAGCGGTGCTGGGGACCGTCAGCGGACTTACGTTGAGTTGCGGTAGTTTGCACGGTGCTGAGTCCGGACTTCGACTGAGTAGGTTGGTCAGCGACTCGATGACGTCGGTTGCGGTTCGAGGTCGCGTGGGACTGCGCTGTAGCCGACTTGCTTGCTGCGTGTGGTGAGTAGCCGATTCGGTGACGTCGTACGAGTTCAGCGTCTTGCGCGTAGGTTGGACTGAGTGCACCGGAGGTTCGGCTAGCGTTGCGTTGCCGTAGGTTCGAGGACTTGGACCGCGCTGAGGTTACGGACGTTGACTTACGGACCGGTGACTGACGAGGACCGGTTCGCTGGAGTCGAGTACCGACGCTGAGTGCAGCGGCTGCGTACGGACTTGCGCGGCGACTGTGGACGTGACTAGCTAGCGTCAGCTTGAGTAGCGGTGCAGCTAGCGGCGACGACTTGCGTAGGTCGTTGGGTGCTGCTGCGCTTACGGACCGGTTGTAGGACTTGCGGTACGACTGCGCGTGAGTTGGACTTCGGTCGTGCGTGACTTGCGGGACTTGGGCTTGCCGTAGTTCGACTGCTGACTGGACGTAGGTCTTGACTGAGCGGACTTGACCGGCGTAGGCGGCTTGCGACTAGCTTGAGGCTTGACTGGACTTAGCGCGGACTTGCGTCAGTCGGACTTGGTTGCGACCTGACCTGGACGTAGGTCGACGTTGACCGCGTGGACTTCGATAGCGAAGCTTGACTCGAGCGGACTTGGCAGGACTGCGTAGGTTGAGTGGACTTGGGCGTGTGGCGTGGACTTGGGTGGACTTGGGCTCGACTTGGCAGGTTCGACGTCAGGTCGCGGTCGATCAGCGGACTGTTGAGCTGACTTGCTGACGTGAGTGGACTTGGTCGACTCGCGTGACTGCGGTAGGCTTCGACTGCGCGTAGTCGTAGGCGTGGTTACGGGTTCGCTGCGTGTTGGTCGACGTGCTGGACTTCGCGGACTCGCTCGATGCGTGGTCGTGGCGTCGGTCGAGTGGACTCGTCGGTAGGTGTGGTGGCTGCGTAGCGGACTTGCGTGTAGTTGACTGCGGTAGGTGACCGTAGCTGTAGTGGGTCTGAGCTTGAGGTTCGCGAGTTCGTGTGGTTGGCTAGGACTTGGCTTAGGTGCGACTGCGTCGATCGACTGGGTTCGCTGCGTAGTTGGGTTGACGTGTACGACGCGACTAGCTTGGGACTTGTGACGAGCGGTAGCGTCAGACTCGGAGTTCGACGCTGAGCTGAGCGGACTTTGACTGCGCGTGGCTCGGCTCGACCGTGCGGGACTTACGTACAGTTGTAGCTGGTTGGGACTTGGACTCGGTTTCGCGACTTACGTCGGACTTTGACTTGCGACTCGCTTAGTGGTCGACTGCGTCGGCTTGGAGCGGACTTAGCTCGGACTTTGGTGCGGCTTGCGTAGTTGGTCGTAGCGGATGTCGGACTCGTGGTTTGGGACTTTAGCGGACTTTAGCGGACTCGTGTGGTTTACGCTCGTGTGGTGTCGGTGGACTGTCGGTGCGGTCTGACTCGGCTTGCTCGGCTTGGTGACGTAGCGTCGTGTTCGTGACGTCGGTAGTAGCTGCTGAGTACGTTCGGGACGATGACGTTGGCTAGTTGACGTGGACTTGGAGGTTCGGTAGCGTGGGCGACTTGAGGTCGAGGCTCGTACGGGTTAGCGCTCGATTCGGTGTACGGGCTCGACTTGACTTACCGTGGGTGTGCGCTGTTGTGTGGCTTGTGACGGTTGTGGAGTTGCTGCTTGAGTGCGCGACGTGGCGTTGACTCGGACGTGGACGTGGCTCGAGTGGCGTAGTGTGGACTGGGCTTGACTCGCGCGTGGACTTGGTGCGTCGTAGTCTGACTGCGCGACTGAGCGACTTGAGTTGGTCGTAGCTTGGTGGCTTGAGCGGTGGACTTGACGTGGCTTGAGTGCGACTTGGTGGCTTGCT\n\nAGCTGCGTAGCTGACGGACGTCGCTTAGGGTGCGACGTAGTCGGACTTCGCTAGGACTTCGGTCGACCGGACGTGCTGACTGCGACCGACTCGGACGTAGCTCGCTAGTCGCTAGTCGGGACGACTGCGGACTAGTCGTGACTTGCGCGACTTGACTGCTCGGACCGACTTAGCTGTCGTAGCTGCGTAGGACCGTCGCGACTTCGGACTTCGTCGACGGACTCGACTGGGCTCGACTCGGTCGACCTGGTGGCGGACTGCGCGTAGGACTGCGCGTGGACTTGGACTGCGCTCGACGTACGACCGTTGAGGTCGCGACTGCGCGTGGTTGACCGGTTGTAGGACCGTTTGCGACCGTACGGTGCTAGCTTGGCTCGGCTAGGACTTGCGACTCGTCGTGCTGCGCTGGTCGACCGTAGCTGACCGACTCGTAGTTCGACGACTTGAGGTCGACTCGCGCGGACGTTCGACCGGCGACTGGACTTGGACTCGGCTCGACTGACGTGGCGGACTTGACTTCGCTGGTAGCGTGACTGCGCGACTCGGACTTAGCTCGTAGTACGTACGGTAGTCGCTGGTGGTCGACGGCGTAGTTCGACTGCGCTGGTCGGTTCGACCGTACGCTGCTCGTAGACTTCGACGGGTTACGTAGTGGTCGACTTGCGCGCTGCGTAGTCGCGTAGCTCGACGTACGAC\n\n2885\n697\n[[0 0 0 ... 0 0 0]\n [1 0 0 ... 1 0 0]\n [0 1 0 ... 0 0 0]\n ...\n [0 0 1 ... 0 1 0]\n [0 0 0 ... 0 0 0]\n [0 0 0 ... 0 0 1]]\nNumber of matching regions with length &gt;= 20: 0\nNumber of matching regions with length &gt;= 10: 62\n\nalternatively another possibly better approach is:\nimport numpy as np\nimport matplotlib.pyplot as plt\nwith open('DNA-seq.txt', 'r') as file:\n    sequences = file.readlines()\n    # The first two lines are the sequences\nseq1 = sequences[0].strip()\nseq2 = sequences[1].strip()\n\ndef count_matching_regions_2(seq1, seq2, min_length):\n  try: \n    rows = len(seq1)\n    cols = len(seq2)\n    dot_plot = np.zeros((rows, cols), dtype=int)\n\n    #Make the dot plot\n    for i in range(rows):\n        for j in range(cols):\n            if seq1[i] == seq2[j]:\n                dot_plot[i][j] = 1\n\n    unique_strings_plot = dot_plot.copy()\n    #print(unique_strings_plot)\n\n    for i in range(1,rows):\n        for j in range(1,cols):\n          if unique_strings_plot[i][j] == 1:\n            unique_strings_plot[i][j] = 1 + unique_strings_plot[i-1][j-1]\n          else:\n            continue\n\n    count = np.sum(unique_strings_plot == min_length)\n\n    return dot_plot, count\n\n  except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return None, None\n\ndot_plot, count_20 = count_matching_regions_2(seq1, seq2, 20)\ndot_plot, count_10 = count_matching_regions_2(seq1, seq2, 10)\ndot_plot, count_5 = count_matching_regions_2(seq1, seq2, 5)\n\nprint(f\"Number of matching regions with length &gt;= 20: {count_20}\")\nprint(f\"Number of matching regions with length &gt;= 10: {count_10}\")\nThis should output the same answer\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 5 - Working with data in ‘pandas’\n\n\n\n\n\n\nLevel: \nFind the dataset of human genes I generated from the ‘humanmine’ database humanmine_results_2024.tsv .\nIn reality you should almost ALWAYS plot your dataset to see what it looks like before doing any analysis. In the next section we will explore plotting, however for this exercise:\n\nLoad the data in the CSV into a ‘pandas’ dataframe\nWhat does the dataset show?\nInspect the data - what might you need to do to clean up the data?\nClean up the data\nWhat is the average gene length?\nWhat is the standard deviation around the mean?\nWhat is the most common ontology term name?\nHow many unique genes are there?\nMake a list ordered by gene size\nHow many cytoplasmic genes are there?\nHow many nuclear genes are there?\nHow many genes are both nuclear and cytoplasmic?\nHow many membrane proteins are there?\n\nExtra task: Mess up this dataset to make it a bit closer to what you might see in real life. Now try to work with it in python.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nimport pandas as pd\n\n# Step 1: Load the data (TSV file)\nfile_path = 'humanmine_results_2024.tsv'  # replace with the actual file path\ndf = pd.read_csv(file_path, sep='\\t')  # Read as a TSV (tab-separated values)\n\n# Step 2: Inspect the data\nprint(\"First 5 rows of the dataframe:\\n\", df.head())\nprint(\"\\nDataFrame Info:\\n\", df.info())\nprint(\"len df\",len(df))\n\n# Step 3: Clean the data\n# 1. Drop any columns with entirely irrelevant data (e.g., \"NO VALUE\")\nprint(\"cleaning data\")\ndf = df.drop_duplicates()\nprint(len(df)) # no rows are dropped\n\n\n# Drop columns with only NaN values\ndf = df.dropna(axis=1, how='all')\n\n#also drop unwanted columns\n\ndf = df.drop(columns=['Gene.secondaryIdentifier'])\n\ndf.style.set_table_attributes('style=\"width:100%; border: 1px solid black;\"')\n\n# you could process this more but for now I'll move onto the second step which is to find the average gene length\n# I will make a deepcopy\ndf_meanlen = df.copy(deep=True)\n#we can remove the unnecessary columns \ndf_meanlen = df_meanlen.drop(columns=['Gene.goAnnotation.ontologyTerm.identifier', 'Gene.goAnnotation.ontologyTerm.name'])\n# we can drop all the duplicates where the primary identifier is the same\ndf_meanlen = df_meanlen.drop_duplicates(subset=['Gene.primaryIdentifier'])\n# we can drop all the rows where there is a NaN in the Gene.length column\ndf_meanlen = df_meanlen.dropna(subset=['Gene.length'])\n# drop any rows with zero values in genelength\ndf_meanlen = df_meanlen[df_meanlen['Gene.length'] != 0]\n# we might now check to see how many NaN values there are in gene description\nprint('empty brief description rows',df_meanlen['Gene.briefDescription'].isna().sum())\n# we can calculate mean now. \n#As a biologist - I know that some of these are possibly alternate isoforms of the same protein.\n#make sure all the types in the gene.length column are the same:\nprint('unique types in length column',df['Gene.length'].apply(type).unique())\n#all floats\n\n\n# What is the average gene length?\naverage_gene_length = df_meanlen['Gene.length'].mean()\nprint(f\"Average gene length: {average_gene_length}\")\n\n# What is the standard deviation around the mean gene length?\nstd_dev_gene_length = df_meanlen['Gene.length'].std()\nprint(f\"Standard deviation of gene length: {std_dev_gene_length}\")\n# If you had plotted the dataset you might use these to figure out the bounds to exclude outliers\n\n#What is the most common ontology term name?\nmost_common_ontology = df['Gene.goAnnotation.ontologyTerm.name'].mode()[0]\nprint(f\"Most common ontology term name: {most_common_ontology}\")\n\n#How many unique genes are there?\n#for this one I am going to enforce that both the primary identifier and cytolocation must be unique. (just because I can) \n#We will therefore also drop the ones with no cytolocation \ndf_unique = df.copy(deep=True)\ndf_unique_id = df_unique.drop_duplicates(subset=['Gene.primaryIdentifier'])\nprint('unique-genes by primary identifier =', len(df_unique_id))\ndf_unique_cyt = df_unique_id.drop_duplicates(subset=['Gene.cytoLocation'])\nprint('unique-genes by dropping those with the same cytolocation by keeping those with none =', len(df_unique_cyt))\ndf_unique_cyt = df_unique_cyt.dropna(subset=['Gene.cytoLocation'])\nunique_genes = len(df_unique_cyt)\nprint(f\"Number of unique genes: {unique_genes}\")\n\n#Make a list ordered by gene size\nsorted_by_size = df_unique.sort_values(by='Gene.length', ascending=False)\nprint(\"List of genes ordered by size:\\n\", sorted_by_size[['Gene.primaryIdentifier', 'Gene.length']])\n\n\n#How many cytoplasmic genes are there? \ncytoplasmic_genes = df[df['Gene.goAnnotation.ontologyTerm.name'].str.contains('cyto', case=False, na=False)] #note the difference when cytoplasm is used\ncytoplasmic_count = cytoplasmic_genes['Gene.primaryIdentifier'].nunique()\nprint(f\"Number of cytoplasmic genes: {cytoplasmic_count}\")\n\n#How many cytoplasmic genes are there? \nnuclear_genes = df[df['Gene.goAnnotation.ontologyTerm.name'].str.contains('nucle', case=False, na=False)] #note the difference when nucleus is used\nnuclear_count = nuclear_genes['Gene.primaryIdentifier'].nunique()\nprint(f\"Number of nuclear genes: {nuclear_count}\")\n\n#How many genes are both nuclear and cytoplasmic?\ncyto_nuclear_genes = pd.merge(cytoplasmic_genes, nuclear_genes, on='Gene.primaryIdentifier')\ncyto_nuclear_count = cyto_nuclear_genes['Gene.primaryIdentifier'].nunique()\nprint(f\"Number of genes that are both nuclear and cytoplasmic: {cyto_nuclear_count}\")\n\n#How many membrane proteins are there?\nmembrane_proteins = df[df['Gene.goAnnotation.ontologyTerm.name'].str.contains('membrane', case=False, na=False)]\nmembrane_protein_count = membrane_proteins['Gene.primaryIdentifier'].nunique()\nprint(f\"Number of membrane proteins: {membrane_protein_count}\")\noutput\nFirst 5 rows of the dataframe:\n                  Gene.briefDescription Gene.cytoLocation  Gene.description  \\\n0  1,4-alpha-glucan branching enzyme 1            3p12.2               NaN   \n1  1,4-alpha-glucan branching enzyme 1            3p12.2               NaN   \n2  1,4-alpha-glucan branching enzyme 1            3p12.2               NaN   \n3  1,4-alpha-glucan branching enzyme 1            3p12.2               NaN   \n4  1,4-alpha-glucan branching enzyme 1            3p12.2               NaN   \n\n   Gene.length  Gene.primaryIdentifier  Gene.score Gene.secondaryIdentifier  \\\n0     271943.0                    2632         NaN          ENSG00000114480   \n1     271943.0                    2632         NaN          ENSG00000114480   \n2     271943.0                    2632         NaN          ENSG00000114480   \n3     271943.0                    2632         NaN          ENSG00000114480   \n4     271943.0                    2632         NaN          ENSG00000114480   \n\n  Gene.symbol Gene.goAnnotation.ontologyTerm.identifier  \\\n0        GBE1                                GO:0003844   \n1        GBE1                                GO:0004553   \n2        GBE1                                GO:0005515   \n3        GBE1                                GO:0005737   \n4        GBE1                                GO:0005829   \n\n                 Gene.goAnnotation.ontologyTerm.name  \n0         1,4-alpha-glucan branching enzyme activity  \n1  hydrolase activity, hydrolyzing O-glycosyl com...  \n2                                    protein binding  \n3                                          cytoplasm  \n4                                            cytosol  \n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 277531 entries, 0 to 277530\nData columns (total 10 columns):\n #   Column                                     Non-Null Count   Dtype  \n---  ------                                     --------------   -----  \n 0   Gene.briefDescription                      276807 non-null  object \n 1   Gene.cytoLocation                          277301 non-null  object \n 2   Gene.description                           0 non-null       float64\n 3   Gene.length                                276835 non-null  float64\n 4   Gene.primaryIdentifier                     277531 non-null  int64  \n 5   Gene.score                                 0 non-null       float64\n 6   Gene.secondaryIdentifier                   277334 non-null  object \n 7   Gene.symbol                                277531 non-null  object \n 8   Gene.goAnnotation.ontologyTerm.identifier  277531 non-null  object \n 9   Gene.goAnnotation.ontologyTerm.name        277525 non-null  object \ndtypes: float64(3), int64(1), object(6)\nmemory usage: 21.2+ MB\n\nDataFrame Info:\n None\nlen df 277531\ncleaning data\n277531\nempty brief description rows 5\nunique types in length column [&lt;class 'float'&gt;]\nAverage gene length: 67511.68010812004\nStandard deviation of gene length: 132916.7867771459\nMost common ontology term name: protein binding\nunique-genes by primary identifier = 18221\nunique-genes by dropping those with the same cytolocation by keeping those with none = 1221\nNumber of unique genes: 1220\nList of genes ordered by size:\n         Gene.primaryIdentifier  Gene.length\n55205                    54715    2473592.0\n55207                    54715    2473592.0\n55216                    54715    2473592.0\n55215                    54715    2473592.0\n55214                    54715    2473592.0\n...                        ...          ...\n277526                    4541          NaN\n277527                    4541          NaN\n277528                    4541          NaN\n277529                    4541          NaN\n277530                    4541          NaN\n\n[277531 rows x 2 columns]\nNumber of cytoplasmic genes: 9283\nNumber of nuclear genes: 8343\nNumber of genes that are both nuclear and cytoplasmic: 5249\nNumber of membrane proteins: 9445",
    "crumbs": [
      "Session-2",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>NumPy Arrays and pandas Dataframes</span>"
    ]
  },
  {
    "objectID": "materials/12-numpy-array-and-pandas-dataframes-wa.html#summary",
    "href": "materials/12-numpy-array-and-pandas-dataframes-wa.html#summary",
    "title": "14  NumPy Arrays and pandas Dataframes",
    "section": "14.4 Summary",
    "text": "14.4 Summary\n‘NumPy’ and ‘pandas’ are both useful packages for working with different types of biological data. Now you should be able to choose which to use and be comfortable attempting to manipulate data with them\n\n\n\n\n\n\nKey Points\n\n\n\n\n‘pandas’ is better for data manipulation and analysis where data is in multiple types.\n‘NumPy’ is better for numerical and array operations and is generally quicker.\nThe documentation is a good tool to use to learn ‘pandas’ and ‘NumPy’",
    "crumbs": [
      "Session-2",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>NumPy Arrays and pandas Dataframes</span>"
    ]
  },
  {
    "objectID": "materials/13-data-visualisation-with-matplotlib-and-seaborn.html",
    "href": "materials/13-data-visualisation-with-matplotlib-and-seaborn.html",
    "title": "15  Data Visualisation with matplotlib and seaborn",
    "section": "",
    "text": "15.1 Using matplotlib and seaborn\nmatplotlib is a widely used plotting library in Python, providing a wide range of capabilities\nseaborn is built on top of matplotlib and offers a high-level interface. It simplifies the process of creating plots and enhances their aesthetics.\nImport Required Libraries\n!pip install seaborn\nimport matplotlib.pyplot as plt \nimport seaborn as sns \nimport numpy as np\nimport pandas as pd\nExample Dataset\nFor the example:\nnp.random.seed(42)  \ndata = {  \n       'height': np.random.normal(160, 10, 100),  # Normal distribution (mean=160, std=10)  \n       'weight': np.random.normal(65, 15, 100)    # Normal distribution (mean=65, std=15)  \n       } \n\ndf = pd.DataFrame(data)\nScatter Plot\nCreate a scatter plot to visualize the relationship between height and weight.\nplt.figure(figsize=(8, 5))  \nplt.scatter(df['height'], df['weight'], color='blue', alpha=0.6) \nplt.title('Scatter Plot of Height vs. Weight')  \nplt.xlabel('Height (cm)')  \nplt.ylabel('Weight (kg)')  \nplt.grid()  \nplt.show()\nHistogram\nCreate a histogram to show the distribution of weights.\nplt.figure(figsize=(8, 5)) \nplt.hist(df['weight'], bins=15, color='green', edgecolor='black', alpha=0.7)  \nplt.title('Histogram of Weights')  \nplt.xlabel('Weight (kg)')  \nplt.ylabel('Frequency')  \nplt.grid()  \nplt.show()\nBoxplot with Seaborn\nUse Seaborn to create a boxplot to visualize the distribution of heights.\nplt.figure(figsize=(8, 5))  \nsns.boxplot(y=df['height'], color='orange')  \nplt.title('Boxplot of Heights')  \nplt.ylabel('Height (cm)')  \nplt.grid() \nplt.show()",
    "crumbs": [
      "Session-2",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Data Visualisation with matplotlib and seaborn</span>"
    ]
  },
  {
    "objectID": "materials/13-data-visualisation-with-matplotlib-and-seaborn.html#using-matplotlib-and-seaborn",
    "href": "materials/13-data-visualisation-with-matplotlib-and-seaborn.html#using-matplotlib-and-seaborn",
    "title": "15  Data Visualisation with matplotlib and seaborn",
    "section": "",
    "text": "Exercise 1 - Visualising humanmine data\n\n\n\n\n\n\nLevel: \nUse ‘matplotlib’ and ‘seaborn’ to plot the humanmine data. Decide what analysis and plots you would like to use.\nAdditional exercise is to plot the memory usage of different datatypes as they increase in size exponentially. Similarly plot the speed of retrieving variables against the size of composite data types. What do you notice?",
    "crumbs": [
      "Session-2",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Data Visualisation with matplotlib and seaborn</span>"
    ]
  },
  {
    "objectID": "materials/13-data-visualisation-with-matplotlib-and-seaborn.html#documentation",
    "href": "materials/13-data-visualisation-with-matplotlib-and-seaborn.html#documentation",
    "title": "15  Data Visualisation with matplotlib and seaborn",
    "section": "15.2 Documentation",
    "text": "15.2 Documentation\nSee the documentation for ‘seaborn’ here:\nhttps://seaborn.pydata.org/\nWaskom, M. L., (2021). seaborn: statistical data visualization. Journal of Open Source Software, 6(60), 3021, https://doi.org/10.21105/joss.03021.\nJ. D. Hunter, “Matplotlib: A 2D Graphics Environment”, Computing in Science & Engineering, vol. 9, no. 3, pp. 90-95, 2007.\nSee the documentation for ‘matplotlib’ here:\nhttps://matplotlib.org/stable/index.html",
    "crumbs": [
      "Session-2",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Data Visualisation with matplotlib and seaborn</span>"
    ]
  },
  {
    "objectID": "materials/13-data-visualisation-with-matplotlib-and-seaborn.html#summary",
    "href": "materials/13-data-visualisation-with-matplotlib-and-seaborn.html#summary",
    "title": "15  Data Visualisation with matplotlib and seaborn",
    "section": "15.3 Summary",
    "text": "15.3 Summary\nNow you have all the tools you need!\nTomorrow we will use all you have learnt so far\n\n\n\n\n\n\nKey Points\n\n\n\n\nPlotting and visualisation is key to understanding and working with data\n‘matplotlib’ and ‘seaborn’ can be used to plot your data in Python",
    "crumbs": [
      "Session-2",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Data Visualisation with matplotlib and seaborn</span>"
    ]
  },
  {
    "objectID": "materials/14-apis-and-biopython.html",
    "href": "materials/14-apis-and-biopython.html",
    "title": "16  API’s and Biopython",
    "section": "",
    "text": "16.1 What is an API?\nAn API (Application Programming Interface) allows different software applications to communicate with each other.\nIn the context of Python and biological data, APIs enable bioinformaticians to access various functionalities and data from externally managed services, libraries, and databases, through Python code. APIs are available in python for NCBI Entrez (including Genbank and Pubmed), Uniprot, Ensembl, KEGG, and Intermine (HumanMine , FlyMine etc.) databases to name a few.\nAPIs allow you to automate queries to biological databases and retrieve data in a rapid and simple way. This can be particularly useful if submitting multiple queries. APIs can also enable you to access analysis software tools through code (e.g. python code). Furthermore, the code used to submit the query often gives greater clarity concerning what information was retrieved, than is sometimes reported in the web interface. This supports clearer documentation.",
    "crumbs": [
      "Session-3",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>API's and Biopython</span>"
    ]
  },
  {
    "objectID": "materials/14-apis-and-biopython.html#example-from-humanmine",
    "href": "materials/14-apis-and-biopython.html#example-from-humanmine",
    "title": "16  API’s and Biopython",
    "section": "16.2 Example from HumanMine",
    "text": "16.2 Example from HumanMine\nHumanMine is an integrated database of human genomics and proteomics data. The web interface query builder also outputs the equivalent python code to retrieve the same data through the API, making it very simple to start to work with the API.\nAn example is below:\n#!/usr/bin/env python\n\n# This is an automatically generated script to run your query\n# to use it you will require the intermine python client.\n# To install the client, run the following command from a terminal:\n#\n#     sudo easy_install intermine\n#\n# For further documentation you can visit:\n#     http://intermine.readthedocs.org/en/latest/web-services/\n\n# The line below will be needed if you are running this script with python 2.\n# Python 3 will ignore it.\nfrom __future__ import print_function\n\n# The following two lines will be needed in every python script:\nfrom intermine.webservice import Service\nservice = Service(\"https://www.humanmine.org/humanmine/service\")\n\n# Get a new query on the class (table) you will be querying:\nquery = service.new_query(\"Gene\")\n\n# The view specifies the output columns\nquery.add_view(\n    \"primaryIdentifier\", \"symbol\", \"name\", \"pathways.name\",\n    \"pathways.dataSets.name\", \"pathways.identifier\", \"organism.shortName\"\n)\n\n# This query's custom sort order is specified below:\nquery.add_sort_order(\"Gene.primaryIdentifier\", \"ASC\")\nquery.add_sort_order(\"Gene.primaryIdentifier\", \"ASC\")\nquery.add_sort_order(\"Gene.primaryIdentifier\", \"ASC\")\n\n# You can edit the constraint values below\nquery.add_constraint(\"Gene\", \"LOOKUP\", \"BRCA1\", code=\"A\")\nquery.add_constraint(\"organism.name\", \"=\", \"Homo sapiens\", code=\"B\")\n\n# Uncomment and edit the code below to specify your own custom logic:\n# query.set_logic(\"B and A\")\n\nfor row in query.rows():\n    print(row[\"primaryIdentifier\"], row[\"symbol\"], row[\"name\"], row[\"pathways.name\"], \\\n        row[\"pathways.dataSets.name\"], row[\"pathways.identifier\"], row[\"organism.shortName\"])\n\nhttps://www.humanmine.org/humanmine",
    "crumbs": [
      "Session-3",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>API's and Biopython</span>"
    ]
  },
  {
    "objectID": "materials/14-apis-and-biopython.html#biopython",
    "href": "materials/14-apis-and-biopython.html#biopython",
    "title": "16  API’s and Biopython",
    "section": "16.3 Biopython",
    "text": "16.3 Biopython\nBiopython is a widely used python package for working with biological data. It includes functions for working with biological data files including ‘fasta’ files, and data structures (classes) for biological data, for example SeqRecord. Modules include: Bio.Seq, Bio.Align, Bio.PDB. It is managed by a team of Bioinformatitions. You can also query some of biological database API’s using Biopython functions, for example you can query the KEGG database. https://biopython.org/docs/latest/Tutorial/chapter_kegg.html\nDocumentation\nhttps://biopython.org/wiki/Documentation\nExample use:\n!pip install biopython\nfrom Bio import SeqIO\nfrom Bio import pairwise2  # Import pairwise2 for alignments\nfrom Bio.pairwise2 import format_alignment  # Import format_alignment to display the results\n\n# Step 1: Parse the FASTA file and extract the first 100 sequences\nfasta_file = \"example.fasta\"  # Path to your FASTA file\nseq_records = []\n\n# Parsing the FASTA file and collecting the first 100 SeqRecord objects\nfor i, record in enumerate(SeqIO.parse(fasta_file, \"fasta\")):\n    if i &lt; 100:\n        seq_records.append(record)\n    else:\n        break\n\n# Step 2: Write the 100 sequences to a temporary file\nwith open(\"subset_100.fasta\", \"w\") as output_handle:\n    SeqIO.write(seq_records, output_handle, \"fasta\")\n\n# Step 3: Align the sequences using Clustal Omega (you need Clustal Omega installed)\n# Clustal Omega command-line tool should be installed and accessible in your system\n# Parse only the first two sequences from the FASTA file\nfor i, record in enumerate(SeqIO.parse(fasta_file, \"fasta\")):\n    if i &lt; 2:\n        seq_records.append(record)\n    else:\n        break\n\n# Step 2: Extract the sequences from the SeqRecord objects\nseq1 = seq_records[0].seq\nseq2 = seq_records[1].seq\n\n# Step 3: Perform pairwise alignment using Biopython's pairwise2 module\nalignments = pairwise2.align.globalxx(seq1, seq2)\n\n# Step 4: Display the alignment results\n# The globalxx method aligns globally, using simple match scoring (1 for match, 0 for mismatch/gap)\nfor alignment in alignments:\n    print(pairwise2.format_alignment(*alignment))\n\nOutput:\nRequirement already satisfied: biopython in /usr/local/lib/python3.10/dist-packages (1.84)\nRequirement already satisfied: numpy in /usr/local/lib/python3.10/dist-packages (from biopython) (1.26.4)\n/usr/local/lib/python3.10/dist-packages/Bio/pairwise2.py:278: BiopythonDeprecationWarning: Bio.pairwise2 has been deprecated, and we intend to remove it in a future release of Biopython. As an alternative, please consider using Bio.Align.PairwiseAligner as a replacement, and contact the Biopython developers if you still need the Bio.pairwise2 module.\n  warnings.warn(\nAAAAAAACCACCGCTACCAGCGGTGGTTTGTTTGCCGGATCAAGAGCTACCAACTCTTTTTCCGAGGTAACTGGCTTCAGCAGAGCGCAGATACCAAATACTGTTCTTCTAGTGTAGCCGTAGTTAGGCCACCACTTCAAGAACTCTGTAGCACCGCCTACATACCTCGCTCTGCTAATCCTGTTACCAGTGGCTGCTGCCAGTGGCGATAAGTCGTGTCTTACCGGGTTGGACTCAAGACGATAGTTACCGGATAAGGCGCAGCGGTCGGGCTGAACGGGGGGTTCGTGCACACAGCCCAGCTTGGAGCGAACGACCTACACCGAACTGAGATACCTACAGCGTGAGCTATGAGAAAGCGCCACGCTTCCCGAAGGGAGAAAGGCGGACAGGTATCCGGTAAGCGGCAGGGTCGGAACAGGAGAGCGCACGAGGGAGCTTCCAGGGGGAAACGCCTGGTATCTTTATAGTCCTGTCGGGTTTCGCCACCTCTGACTTGAGCATCGATTTTTGTGATGCTCGTCAGGGGGGCGGAGCCTATGGAAAAACGCCAGCAACGCAGAAAGGCCCACCCGAAGGTGAGCCAGGTGATTACATTTGGGCCCTCATCAGAGGTTTTCACCGTCATCACCGAAACGCGCGAGGCAGCTGCGGTAAAGCTCATCAGCGTGGTCGTGAAGCGATTCACAGATGTCTGCCTGTTCATCCGCGTCCAGCTCGTTGAGTTTCTCCAGAAGCGTTAATGTCTGGCTTCTGATAAAGCGGGCCATGTTAAGGGCGGTTTTTTCCTGTTTGGTCACTTACCAATGCTTAATCAGTGAGGCACCTATCTCAGCGATCTGTCTATTTCGTTCATCCATAGTTGCCTGACTCCCCGTCGTGTAGATAACTACGATGCGGGAGGGCTTACCATCTGGCCCCAGTGCTGCAATGATACCGCGAGACCCACGCTCACCGGCTCCAGATTTATCAGCAATAAACCAGCCAGCCGGGAGTGCCGAGCGCAGAAGTGATCCTGCAACTTTATCCGCCTCCATCCAGTCTATTAATTGTTGCCGGGAAGCTAGAGTAAGTAGTTCGCCAGTTAATAGTTTGCGCAACGTTGTTGCCATTGCTACAGGCATCGTGGTGTCACGCTCGTCGTTTGGTATGGCTTCATTCAGCTCCGGTTCCCAACGATCAAGGCGAGTTACATGATCCCCCATGTTGTGCAAAAAAGCGGTTAGCTCCTTCGGTCCTCCGATCGTTGCCAGAAGTAAGTTGGCCGCAGTGTTATCACTCATGGTTATGGCAGCACTGCATAATTCTCTTACTGTCATGCCATCCGTGAGATGCTTTTCTGTGACTGGTGAGTACTCAACCAAGTCATTCTGAGAATAGTGTATGCGGCGACCGAGTTGCTCTTGCCCGGCGTCAATACGGGATAATACCGCGCCACATAGCAGAACTTTAAAAGTGCTCATCATTGGAAAACGTTCTTCGGGGCGTAAACTCTCAAGGATCTTACCGCTGTTGAGATCCAGTTCGATGTAACCCACTCGTGCACCCAACTGATCTTCAGCATCTTTTACTTTCACCAGCGTTTCTGGGTGAGCAAAAACAGGAAGGCAAAATGCCGCAAAAAAGGGAATAAGGGCGACACGGAAATGTTGAATACTCATTTTAGCTTCCTTAGCTCCTGAAAATCTCGATAACTCAAAAAATACGCCCGGTAGTGATCTTATTTCATTATGGTGAAAGTTGGAACCTCTTACGTGCCGATCAAGTCAAAAGCCTCCGGTCGGAGGCTTTTGACTTTCTGCTATGGAGGTCAGGTATGATTTAAATGGTCAGTGATGAACGCACAGCGAAATGGGGAGCCAAAAAACCCCTCAAGACCCGTTTAGAGGCCCCAAGGGGTTATGCTAGCATAAATCATAAGAAATTCGCGCCATACCTATTAAGACTCCTTATTACGCAGTATGTTAGCAAACGTAGAAAATACATACATAAAGGTGGCAACATATAAAAGAAACGCAAAGACACCACGGAATAAGTTTATTTTGTCACAATCAATAGAAAATTCATATGGTTTACCAGCGCCAAAGACAAAAGGGCGACATTCAACCGATTGAGGGAGGGAAGGTAAATATTGACGGAAATTATTCATTAAAGGTGAATTATCACCGTCACCGACTTGAGCCATTTGGGAATTAGAGCCAGCAAAATCACCAGTAGCACCATTACCATTAGCAAGGCCGGAAACGTCACCAATGAAACCATCGATAGCAGCACCGTAATCAGTAGCGACAGAATCAAGTTTGCCTTTAGCGTCAGACTGTAGCGCGTTTTCATCGGCATTTTCGGTCATAGCCCCCTTATTAGCGTTTGCCATCTTTTCATAATCAAAATCACCGGAACCAGAGCCACCACCGGAACCGCCTCCCTCAGAGCCGCCACCCTCAGAACCGCCACCCTCAGAGCCACCACCCTCAGAGCCGCCACCAGAACCACCACCAGAGCCGCCGCCAGCATTGACAGGAGGTTGAGGCAGGTCAGACGATTGGCCTTGATATTCACAAACGAATGGATCCTCATTAAAGCCAGAATGGAAAGCGCAGTCTCTGAATTTACCGTTCCAGTAAGCGTCATACATGGCTTTTGATGATACAGGAGTGTACTGGTAATAAGTTTTAACGGGGTCAGTGCCTTGAGTAACAGTGCCCGTATAAACAGTTAATGCCCCCTGCCTATTTCGGAACCTATTATTCTGAAACATGAAAGTATTAAGAGGCTGAGACTCCTCAAGAGAAGGATTAGGATTAGCGGGGTTTTGCTCAGTACCAGGCGGATAAGTGCCGTCGAGAGGGTTGATATAAGTATAGCCCGGAATAGGTGTATCACCGTACTCAGGAGGTTTAGTACCGCCACCCTCAGAACCGCCACCCTCAGAACCGCCACCCTCAGAGCCACCACCCTCATTTTCAGGGATAGCAAGCCCAATAGGAACCCATGTACCGTAACACTGAGTTTCGTCACCAGTACAAACTACAACGCCTGTAGCATTCCACAGACAGCCCTCATAGTTAGCGTAACGATCTAAAGTTTTGTCGTCTTTCCAGACGTTAGTAAATGAATTTTCTGTATGGGGTTTTGCTAAACAACTTTCAACAGTTTCAGCGGAGTGAGAATAGAAAGGAACAACTAAAGGAATTGCGAATAATAATTTTTTCATTTAGTATTTCTCCTCTTTAATCTAGTAGCTAAGATCCATTCCCTTTAGTGAGGCTAAATACAGTGGAGAGCGTTCACCGACAAACAACAGATAAAACGAAAGCCAGTCTTTCGACTGAGCCTTTCGTTTTATTTGAAGCTTGACTCCAGCGTAACTGGACTGCAATCAACTCACTGGCTCACCTTCACGGGTGGGCCTTTCTTCGGTAGAAAATCAAAGGATCTTCTTGAGATCCTTTTTTTCTGCGCGTAATCTGCTGCTTGCAAAC\n||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\nAAAAAAACCACCGCTACCAGCGGTGGTTTGTTTGCCGGATCAAGAGCTACCAACTCTTTTTCCGAGGTAACTGGCTTCAGCAGAGCGCAGATACCAAATACTGTTCTTCTAGTGTAGCCGTAGTTAGGCCACCACTTCAAGAACTCTGTAGCACCGCCTACATACCTCGCTCTGCTAATCCTGTTACCAGTGGCTGCTGCCAGTGGCGATAAGTCGTGTCTTACCGGGTTGGACTCAAGACGATAGTTACCGGATAAGGCGCAGCGGTCGGGCTGAACGGGGGGTTCGTGCACACAGCCCAGCTTGGAGCGAACGACCTACACCGAACTGAGATACCTACAGCGTGAGCTATGAGAAAGCGCCACGCTTCCCGAAGGGAGAAAGGCGGACAGGTATCCGGTAAGCGGCAGGGTCGGAACAGGAGAGCGCACGAGGGAGCTTCCAGGGGGAAACGCCTGGTATCTTTATAGTCCTGTCGGGTTTCGCCACCTCTGACTTGAGCATCGATTTTTGTGATGCTCGTCAGGGGGGCGGAGCCTATGGAAAAACGCCAGCAACGCAGAAAGGCCCACCCGAAGGTGAGCCAGGTGATTACATTTGGGCCCTCATCAGAGGTTTTCACCGTCATCACCGAAACGCGCGAGGCAGCTGCGGTAAAGCTCATCAGCGTGGTCGTGAAGCGATTCACAGATGTCTGCCTGTTCATCCGCGTCCAGCTCGTTGAGTTTCTCCAGAAGCGTTAATGTCTGGCTTCTGATAAAGCGGGCCATGTTAAGGGCGGTTTTTTCCTGTTTGGTCACTTACCAATGCTTAATCAGTGAGGCACCTATCTCAGCGATCTGTCTATTTCGTTCATCCATAGTTGCCTGACTCCCCGTCGTGTAGATAACTACGATGCGGGAGGGCTTACCATCTGGCCCCAGTGCTGCAATGATACCGCGAGACCCACGCTCACCGGCTCCAGATTTATCAGCAATAAACCAGCCAGCCGGGAGTGCCGAGCGCAGAAGTGATCCTGCAACTTTATCCGCCTCCATCCAGTCTATTAATTGTTGCCGGGAAGCTAGAGTAAGTAGTTCGCCAGTTAATAGTTTGCGCAACGTTGTTGCCATTGCTACAGGCATCGTGGTGTCACGCTCGTCGTTTGGTATGGCTTCATTCAGCTCCGGTTCCCAACGATCAAGGCGAGTTACATGATCCCCCATGTTGTGCAAAAAAGCGGTTAGCTCCTTCGGTCCTCCGATCGTTGCCAGAAGTAAGTTGGCCGCAGTGTTATCACTCATGGTTATGGCAGCACTGCATAATTCTCTTACTGTCATGCCATCCGTGAGATGCTTTTCTGTGACTGGTGAGTACTCAACCAAGTCATTCTGAGAATAGTGTATGCGGCGACCGAGTTGCTCTTGCCCGGCGTCAATACGGGATAATACCGCGCCACATAGCAGAACTTTAAAAGTGCTCATCATTGGAAAACGTTCTTCGGGGCGTAAACTCTCAAGGATCTTACCGCTGTTGAGATCCAGTTCGATGTAACCCACTCGTGCACCCAACTGATCTTCAGCATCTTTTACTTTCACCAGCGTTTCTGGGTGAGCAAAAACAGGAAGGCAAAATGCCGCAAAAAAGGGAATAAGGGCGACACGGAAATGTTGAATACTCATTTTAGCTTCCTTAGCTCCTGAAAATCTCGATAACTCAAAAAATACGCCCGGTAGTGATCTTATTTCATTATGGTGAAAGTTGGAACCTCTTACGTGCCGATCAAGTCAAAAGCCTCCGGTCGGAGGCTTTTGACTTTCTGCTATGGAGGTCAGGTATGATTTAAATGGTCAGTGATGAACGCACAGCGAAATGGGGAGCCAAAAAACCCCTCAAGACCCGTTTAGAGGCCCCAAGGGGTTATGCTAGCATAAATCATAAGAAATTCGCGCCATACCTATTAAGACTCCTTATTACGCAGTATGTTAGCAAACGTAGAAAATACATACATAAAGGTGGCAACATATAAAAGAAACGCAAAGACACCACGGAATAAGTTTATTTTGTCACAATCAATAGAAAATTCATATGGTTTACCAGCGCCAAAGACAAAAGGGCGACATTCAACCGATTGAGGGAGGGAAGGTAAATATTGACGGAAATTATTCATTAAAGGTGAATTATCACCGTCACCGACTTGAGCCATTTGGGAATTAGAGCCAGCAAAATCACCAGTAGCACCATTACCATTAGCAAGGCCGGAAACGTCACCAATGAAACCATCGATAGCAGCACCGTAATCAGTAGCGACAGAATCAAGTTTGCCTTTAGCGTCAGACTGTAGCGCGTTTTCATCGGCATTTTCGGTCATAGCCCCCTTATTAGCGTTTGCCATCTTTTCATAATCAAAATCACCGGAACCAGAGCCACCACCGGAACCGCCTCCCTCAGAGCCGCCACCCTCAGAACCGCCACCCTCAGAGCCACCACCCTCAGAGCCGCCACCAGAACCACCACCAGAGCCGCCGCCAGCATTGACAGGAGGTTGAGGCAGGTCAGACGATTGGCCTTGATATTCACAAACGAATGGATCCTCATTAAAGCCAGAATGGAAAGCGCAGTCTCTGAATTTACCGTTCCAGTAAGCGTCATACATGGCTTTTGATGATACAGGAGTGTACTGGTAATAAGTTTTAACGGGGTCAGTGCCTTGAGTAACAGTGCCCGTATAAACAGTTAATGCCCCCTGCCTATTTCGGAACCTATTATTCTGAAACATGAAAGTATTAAGAGGCTGAGACTCCTCAAGAGAAGGATTAGGATTAGCGGGGTTTTGCTCAGTACCAGGCGGATAAGTGCCGTCGAGAGGGTTGATATAAGTATAGCCCGGAATAGGTGTATCACCGTACTCAGGAGGTTTAGTACCGCCACCCTCAGAACCGCCACCCTCAGAACCGCCACCCTCAGAGCCACCACCCTCATTTTCAGGGATAGCAAGCCCAATAGGAACCCATGTACCGTAACACTGAGTTTCGTCACCAGTACAAACTACAACGCCTGTAGCATTCCACAGACAGCCCTCATAGTTAGCGTAACGATCTAAAGTTTTGTCGTCTTTCCAGACGTTAGTAAATGAATTTTCTGTATGGGGTTTTGCTAAACAACTTTCAACAGTTTCAGCGGAGTGAGAATAGAAAGGAACAACTAAAGGAATTGCGAATAATAATTTTTTCATTTAGTATTTCTCCTCTTTAATCTAGTAGCTAAGATCCATTCCCTTTAGTGAGGCTAAATACAGTGGAGAGCGTTCACCGACAAACAACAGATAAAACGAAAGCCAGTCTTTCGACTGAGCCTTTCGTTTTATTTGAAGCTTGACTCCAGCGTAACTGGACTGCAATCAACTCACTGGCTCACCTTCACGGGTGGGCCTTTCTTCGGTAGAAAATCAAAGGATCTTCTTGAGATCCTTTTTTTCTGCGCGTAATCTGCTGCTTGCAAAC\n  Score=3482\n** Note here the deprecation warning: tools are constantly changing which is why it is so important to properly manage software and software dependencies!*",
    "crumbs": [
      "Session-3",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>API's and Biopython</span>"
    ]
  },
  {
    "objectID": "materials/14-apis-and-biopython.html#summary",
    "href": "materials/14-apis-and-biopython.html#summary",
    "title": "16  API’s and Biopython",
    "section": "16.4 Summary",
    "text": "16.4 Summary\nBioinformaticians have built a range of tools to aid bioinformatics analysis in Python. This active community and support is one of the great benefits of working with python!\n\n\n\n\n\n\nKey Points\n\n\n\n\nAPI’s can be used to interface softwares with Python, and can be used to access common biological databases.\nBiopython is a commonly used package to work with biological data",
    "crumbs": [
      "Session-3",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>API's and Biopython</span>"
    ]
  },
  {
    "objectID": "materials/15-escape-room.html",
    "href": "materials/15-escape-room.html",
    "title": "17  Escape Room - You are locked in!",
    "section": "",
    "text": "Warning\n\n\n\nI am a rich billionaire. I have kidnapped you budding bioinformaticians studying Part III Systems Biology (with the help of your course organisers), because my mad doctor has run away before telling me my diagnosis.\nI have locked this room! Until you can determine my diagnosis using the clues the mad doctor has left behind, and can tell me how to treat it, I will not let you out!\nIf I die before you can figure it out unfortunately you will be trapped in this room forever….\nThe mad doctor sent me an email after his escape, stating that the skills you acquired in the Introduction to Python course should help you follow the clues he provided in the instructions below and in the encrypted files.\nI was advised to get you to compete in three to four teams. A different person must type in each of the tasks with others only being allowed to talk - not type. There will be extra reward clues on offer for the most elegant solutions.\n\n\n\n\n\n\n\n\nExercise 1 - Mad Doctor’s Instructions\n\n\n\n\n\n\nLevel: \nFirst install the cryptography module.\nThen import the decryptor module provided in decryptor.py to your python script.\nOnly then will you be able to investigate the secret files.\n\nThe clue to generate the password to open the first secret file is a message encoded:\n\n[84, 104, 101, 32, 121, 101, 97, 114, 32, 116, 104, 97, 116, 32, 68, 78, 65, 32, 119, 97, 115, 32, 100, 105, 115, 99, 111, 118, 101, 114, 101, 100, 32, 105, 110]\nUse the password and the decrypt() function to open the file secret_file_1.txt.enc. This will decrypt the secret file and return a decrypted copy in your working directory. Use the help() function to investigate use of the module and function.\n\n\n\n\nTo find the clue in the secret_file_1.txt, load this sequence and pull the characters at the fibonacci numbers.\n\nThe password to decrypt secret_file_2.tsv.enc is all lowercase: (third-word-in-clue) + (first word in the clue) + (6th letter in the 5th word) + (the last word backwards)\n\n\nTo find the clue in the second file, read the secret_file_2.csv. Multiply the animal_weight by 4, and log transform the madness_index using the natural log. Plot the output as a scatter plot.\n\nThe password to decrypt secret_file_3.txt.enc is the first 5 letters of the cell type represented - all in Upper case\n\n\n\nPlot the equations in secret_file_3.txt. This will show you the clue.\n\nThe password to decrypt secret_file_4.tsv.enc is an animal all upper case.\n\n\nWrite code to pull out and print the unexpected values in the data to find the clue in secret_file_4.tsv\n\nThe password for secret_file_5.txt.enc is in the clue. The password is all lower case.\n\n\nOpen secret_file_5.txt. Put the amino acid sequence contents into a numpy array. Each letter should be in a new element in the array and each line forms a new row. Order the amino acids in alphabetical order. Convert the array to numeric encoding, with A being represented by ‘0’ and the last amino acid by ‘19’. Plot a heatmap of your matrix.\n\nThe family name of the animal species in the heatmap (all lower case) is the clue to decrypt the next file, secret_file_6.txt.enc.\n\n\nThe message clue in secret_file_6.txt is encoded as triangular numbers where ‘a’ = 1 and therefore the first triangular number and ‘z’ = 26, and therefore the 26th triangular number. Write code to retrieve the message.\n\nThe last two words without gaps (all lower case) is the password for the final clue in secret_file_7.txt.enc.\n\nFor the last clue, load the dictionary in secret_file_7.txt. The next word in the clue can be retrieved by using the “key” which equals the current word’s “value”. The first word in the clue is “If”",
    "crumbs": [
      "Session-3",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Escape Room - You are locked in!</span>"
    ]
  },
  {
    "objectID": "materials/15-escape-room-wa.html",
    "href": "materials/15-escape-room-wa.html",
    "title": "18  Answers for Escape Room - You are locked in!",
    "section": "",
    "text": "18.1 Congratulations\nCongratulations if you successfully figured out my diagnosis! You may now leave the room. I must hurry and get treated before symptoms start to occur!",
    "crumbs": [
      "Session-3",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Answers for Escape Room - You are locked in!</span>"
    ]
  },
  {
    "objectID": "materials/15-escape-room-wa.html#congratulations",
    "href": "materials/15-escape-room-wa.html#congratulations",
    "title": "18  Answers for Escape Room - You are locked in!",
    "section": "",
    "text": "Answer\n\n\n\n\n\n\nAh yes - that makes sense - as I was bitten by a dog on my tropical holiday! I may have rabies. I must quickly go and get the shot’s required! Thank goodness you are here, as my mad doctor dissapeared without telling me!",
    "crumbs": [
      "Session-3",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Answers for Escape Room - You are locked in!</span>"
    ]
  },
  {
    "objectID": "materials/15-escape-room-wa.html#conclusion-and-summary",
    "href": "materials/15-escape-room-wa.html#conclusion-and-summary",
    "title": "18  Answers for Escape Room - You are locked in!",
    "section": "18.2 Conclusion and Summary",
    "text": "18.2 Conclusion and Summary\nHopefully that was a fun exercise! Please see the key takeaways from this course\n\n\n\n\n\n\nKey Points\n\n\n\n\nPython is defined by the syntax, and is an easy to use high level language commonly used in data science\nPython has many packages and modules for data science and AI\nThere are both advantages and disadvantages to programming in python, so choose a programming language suited to the task\nchoosing the best data types and operators is key to good concise and fast code\nUnderstanding the basics of deep and shallow copies and how objects are stored in memory can help prevent errors in code\nMemory management and speed of code can be important so benchmarking is useful\nUsing conditionals, match statements, for loops and while loops enable one to build more complex programs\nfunctions and classes in python help structure code and reflect the object-oriented programming approach\nPackage and environment managers like Conda are helpful to manage software dependencies\nPackages like ‘pandas’, ‘NumPy’, ‘matplotlib’ and ‘seaborn’, enable data analysis and are well documented\nAnd most importantly always document your code!",
    "crumbs": [
      "Session-3",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Answers for Escape Room - You are locked in!</span>"
    ]
  }
]